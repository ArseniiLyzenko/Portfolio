/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/icons/at-solid.svg":
/*!********************************!*\
  !*** ./src/icons/at-solid.svg ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"at-solid.svg\");\n\n//# sourceURL=webpack:///./src/icons/at-solid.svg?");

/***/ }),

/***/ "./src/icons/github-brands.svg":
/*!*************************************!*\
  !*** ./src/icons/github-brands.svg ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"github-brands.svg\");\n\n//# sourceURL=webpack:///./src/icons/github-brands.svg?");

/***/ }),

/***/ "./src/icons/linkedin-brands.svg":
/*!***************************************!*\
  !*** ./src/icons/linkedin-brands.svg ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"linkedin-brands.svg\");\n\n//# sourceURL=webpack:///./src/icons/linkedin-brands.svg?");

/***/ }),

/***/ "./src/index.html":
/*!************************!*\
  !*** ./src/index.html ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"index.html\");\n\n//# sourceURL=webpack:///./src/index.html?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.html */ \"./src/index.html\");\n/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/index.scss */ \"./src/styles/index.scss\");\n/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _icons_at_solid_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons/at-solid.svg */ \"./src/icons/at-solid.svg\");\n/* harmony import */ var _icons_github_brands_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icons/github-brands.svg */ \"./src/icons/github-brands.svg\");\n/* harmony import */ var _icons_linkedin_brands_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icons/linkedin-brands.svg */ \"./src/icons/linkedin-brands.svg\");\n/* harmony import */ var _scripts_hint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/hint */ \"./src/scripts/hint.js\");\n/* harmony import */ var _scripts_hint__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_scripts_hint__WEBPACK_IMPORTED_MODULE_5__);\n\r\n\r\n\r\n\r\n// import '@fortawesome/fontawesome-free/js/all.min';\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst impress_DOM_element = document.getElementById(\"impress\");\r\n\r\n// impress_DOM_element.dataset.height = window.innerHeight;\r\n// impress_DOM_element.dataset.width = window.innerWidth;\r\n\r\nimpress_DOM_element.dataset.height = impress_DOM_element.dataset.width =\r\n  window.innerHeight < window.innerWidth\r\n    ? window.innerHeight\r\n    : window.innerWidth;\r\n\r\nimpress().init();\r\n\r\n// if (\"ontouchstart\" in document.documentElement) {\r\n//\r\n// }\r\n// console.log(impress_DOM_element);\r\n// debugger\r\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/libraries/impress.js":
/*!**********************************!*\
  !*** ./src/libraries/impress.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// This file was automatically generated from files in src/ directory.\r\n\r\n/*! Licensed under MIT License - http://github.com/impress/impress.js */\r\n/**\r\n * impress.js\r\n *\r\n * impress.js is a presentation tool based on the power of CSS3 transforms and transitions\r\n * in modern browsers and inspired by the idea behind prezi.com.\r\n *\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz), 2016-2018 Henrik Ingo (@henrikingo)\r\n *\r\n * Released under the MIT License.\r\n *\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka, Henrik Ingo\r\n *  version: 1.0.0\r\n *  url:     http://impress.js.org\r\n *  source:  http://github.com/impress/impress.js/\r\n */\r\n\r\n// You are one of those who like to know how things work inside?\r\n// Let me show you the cogs that make impress.js run...\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var lib;\r\n\r\n    // HELPER FUNCTIONS\r\n\r\n    // `pfx` is a function that takes a standard CSS property name as a parameter\r\n    // and returns it's prefixed version valid for current browser it runs in.\r\n    // The code is heavily inspired by Modernizr http://www.modernizr.com/\r\n    var pfx = ( function() {\r\n\r\n        var style = document.createElement( \"dummy\" ).style,\r\n            prefixes = \"Webkit Moz O ms Khtml\".split( \" \" ),\r\n            memory = {};\r\n\r\n        return function( prop ) {\r\n            if ( typeof memory[ prop ] === \"undefined\" ) {\r\n\r\n                var ucProp  = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),\r\n                    props   = ( prop + \" \" + prefixes.join( ucProp + \" \" ) + ucProp ).split( \" \" );\r\n\r\n                memory[ prop ] = null;\r\n                for ( var i in props ) {\r\n                    if ( style[ props[ i ] ] !== undefined ) {\r\n                        memory[ prop ] = props[ i ];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            return memory[ prop ];\r\n        };\r\n\r\n    } )();\r\n\r\n    var validateOrder = function( order, fallback ) {\r\n        var validChars = \"xyz\";\r\n        var returnStr = \"\";\r\n        if ( typeof order === \"string\" ) {\r\n            for ( var i in order.split( \"\" ) ) {\r\n                if ( validChars.indexOf( order[ i ] ) >= 0 ) {\r\n                    returnStr += order[ i ];\r\n\r\n                    // Each of x,y,z can be used only once.\r\n                    validChars = validChars.split( order[ i ] ).join( \"\" );\r\n                }\r\n            }\r\n        }\r\n        if ( returnStr ) {\r\n            return returnStr;\r\n        } else if ( fallback !== undefined ) {\r\n            return fallback;\r\n        } else {\r\n            return \"xyz\";\r\n        }\r\n    };\r\n\r\n    // `css` function applies the styles given in `props` object to the element\r\n    // given as `el`. It runs all property names through `pfx` function to make\r\n    // sure proper prefixed version of the property is used.\r\n    var css = function( el, props ) {\r\n        var key, pkey;\r\n        for ( key in props ) {\r\n            if ( props.hasOwnProperty( key ) ) {\r\n                pkey = pfx( key );\r\n                if ( pkey !== null ) {\r\n                    el.style[ pkey ] = props[ key ];\r\n                }\r\n            }\r\n        }\r\n        return el;\r\n    };\r\n\r\n    // `translate` builds a translate transform string for given data.\r\n    var translate = function( t ) {\r\n        return \" translate3d(\" + t.x + \"px,\" + t.y + \"px,\" + t.z + \"px) \";\r\n    };\r\n\r\n    // `rotate` builds a rotate transform string for given data.\r\n    // By default the rotations are in X Y Z order that can be reverted by passing `true`\r\n    // as second parameter.\r\n    var rotate = function( r, revert ) {\r\n        var order = r.order ? r.order : \"xyz\";\r\n        var css = \"\";\r\n        var axes = order.split( \"\" );\r\n        if ( revert ) {\r\n            axes = axes.reverse();\r\n        }\r\n\r\n        for ( var i = 0; i < axes.length; i++ ) {\r\n            css += \" rotate\" + axes[ i ].toUpperCase() + \"(\" + r[ axes[ i ] ] + \"deg)\";\r\n        }\r\n        return css;\r\n    };\r\n\r\n    // `scale` builds a scale transform string for given data.\r\n    var scale = function( s ) {\r\n        return \" scale(\" + s + \") \";\r\n    };\r\n\r\n    // `computeWindowScale` counts the scale factor between window size and size\r\n    // defined for the presentation in the config.\r\n    var computeWindowScale = function( config ) {\r\n        var hScale = window.innerHeight / config.height,\r\n            wScale = window.innerWidth / config.width,\r\n            scale = hScale > wScale ? wScale : hScale;\r\n\r\n        if ( config.maxScale && scale > config.maxScale ) {\r\n            scale = config.maxScale;\r\n        }\r\n\r\n        if ( config.minScale && scale < config.minScale ) {\r\n            scale = config.minScale;\r\n        }\r\n\r\n        return scale;\r\n    };\r\n\r\n    // CHECK SUPPORT\r\n    var body = document.body;\r\n    var impressSupported =\r\n\r\n                          // Browser should support CSS 3D transtorms\r\n                           ( pfx( \"perspective\" ) !== null ) &&\r\n\r\n                          // And `classList` and `dataset` APIs\r\n                           ( body.classList ) &&\r\n                           ( body.dataset );\r\n\r\n    if ( !impressSupported ) {\r\n\r\n        // We can't be sure that `classList` is supported\r\n        body.className += \" impress-not-supported \";\r\n    }\r\n\r\n    // GLOBALS AND DEFAULTS\r\n\r\n    // This is where the root elements of all impress.js instances will be kept.\r\n    // Yes, this means you can have more than one instance on a page, but I'm not\r\n    // sure if it makes any sense in practice ;)\r\n    var roots = {};\r\n\r\n    var preInitPlugins = [];\r\n    var preStepLeavePlugins = [];\r\n\r\n    // Some default config values.\r\n    var defaults = {\r\n        width: 1024,\r\n        height: 768,\r\n        maxScale: 1,\r\n        minScale: 0,\r\n\r\n        perspective: 1000,\r\n\r\n        transitionDuration: 1000\r\n    };\r\n\r\n    // It's just an empty function ... and a useless comment.\r\n    var empty = function() { return false; };\r\n\r\n    // IMPRESS.JS API\r\n\r\n    // And that's where interesting things will start to happen.\r\n    // It's the core `impress` function that returns the impress.js API\r\n    // for a presentation based on the element with given id (\"impress\"\r\n    // by default).\r\n    var impress = window.impress = function( rootId ) {\r\n\r\n        // If impress.js is not supported by the browser return a dummy API\r\n        // it may not be a perfect solution but we return early and avoid\r\n        // running code that may use features not implemented in the browser.\r\n        if ( !impressSupported ) {\r\n            return {\r\n                init: empty,\r\n                goto: empty,\r\n                prev: empty,\r\n                next: empty,\r\n                swipe: empty,\r\n                tear: empty,\r\n                lib: {}\r\n            };\r\n        }\r\n\r\n        rootId = rootId || \"impress\";\r\n\r\n        // If given root is already initialized just return the API\r\n        if ( roots[ \"impress-root-\" + rootId ] ) {\r\n            return roots[ \"impress-root-\" + rootId ];\r\n        }\r\n\r\n        // The gc library depends on being initialized before we do any changes to DOM.\r\n        lib = initLibraries( rootId );\r\n\r\n        body.classList.remove( \"impress-not-supported\" );\r\n        body.classList.add( \"impress-supported\" );\r\n\r\n        // Data of all presentation steps\r\n        var stepsData = {};\r\n\r\n        // Element of currently active step\r\n        var activeStep = null;\r\n\r\n        // Current state (position, rotation and scale) of the presentation\r\n        var currentState = null;\r\n\r\n        // Array of step elements\r\n        var steps = null;\r\n\r\n        // Configuration options\r\n        var config = null;\r\n\r\n        // Scale factor of the browser window\r\n        var windowScale = null;\r\n\r\n        // Root presentation elements\r\n        var root = lib.util.byId( rootId );\r\n        var canvas = document.createElement( \"div\" );\r\n\r\n        var initialized = false;\r\n\r\n        // STEP EVENTS\r\n        //\r\n        // There are currently two step events triggered by impress.js\r\n        // `impress:stepenter` is triggered when the step is shown on the\r\n        // screen (the transition from the previous one is finished) and\r\n        // `impress:stepleave` is triggered when the step is left (the\r\n        // transition to next step just starts).\r\n\r\n        // Reference to last entered step\r\n        var lastEntered = null;\r\n\r\n        // `onStepEnter` is called whenever the step element is entered\r\n        // but the event is triggered only if the step is different than\r\n        // last entered step.\r\n        // We sometimes call `goto`, and therefore `onStepEnter`, just to redraw a step, such as\r\n        // after screen resize. In this case - more precisely, in any case - we trigger a\r\n        // `impress:steprefresh` event.\r\n        var onStepEnter = function( step ) {\r\n            if ( lastEntered !== step ) {\r\n                lib.util.triggerEvent( step, \"impress:stepenter\" );\r\n                lastEntered = step;\r\n            }\r\n            lib.util.triggerEvent( step, \"impress:steprefresh\" );\r\n        };\r\n\r\n        // `onStepLeave` is called whenever the currentStep element is left\r\n        // but the event is triggered only if the currentStep is the same as\r\n        // lastEntered step.\r\n        var onStepLeave = function( currentStep, nextStep ) {\r\n            if ( lastEntered === currentStep ) {\r\n                lib.util.triggerEvent( currentStep, \"impress:stepleave\", { next: nextStep } );\r\n                lastEntered = null;\r\n            }\r\n        };\r\n\r\n        // `initStep` initializes given step element by reading data from its\r\n        // data attributes and setting correct styles.\r\n        var initStep = function( el, idx ) {\r\n            var data = el.dataset,\r\n                step = {\r\n                    translate: {\r\n                        x: lib.util.toNumber( data.x ),\r\n                        y: lib.util.toNumber( data.y ),\r\n                        z: lib.util.toNumber( data.z )\r\n                    },\r\n                    rotate: {\r\n                        x: lib.util.toNumber( data.rotateX ),\r\n                        y: lib.util.toNumber( data.rotateY ),\r\n                        z: lib.util.toNumber( data.rotateZ || data.rotate ),\r\n                        order: validateOrder( data.rotateOrder )\r\n                    },\r\n                    scale: lib.util.toNumber( data.scale, 1 ),\r\n                    transitionDuration: lib.util.toNumber(\r\n                        data.transitionDuration, config.transitionDuration\r\n                    ),\r\n                    el: el\r\n                };\r\n\r\n            if ( !el.id ) {\r\n                el.id = \"step-\" + ( idx + 1 );\r\n            }\r\n\r\n            stepsData[ \"impress-\" + el.id ] = step;\r\n\r\n            css( el, {\r\n                position: \"absolute\",\r\n                transform: \"translate(-50%,-50%)\" +\r\n                           translate( step.translate ) +\r\n                           rotate( step.rotate ) +\r\n                           scale( step.scale ),\r\n                transformStyle: \"preserve-3d\"\r\n            } );\r\n        };\r\n\r\n        // Initialize all steps.\r\n        // Read the data-* attributes, store in internal stepsData, and render with CSS.\r\n        var initAllSteps = function() {\r\n            steps = lib.util.$$( \".step\", root );\r\n            steps.forEach( initStep );\r\n        };\r\n\r\n        // `init` API function that initializes (and runs) the presentation.\r\n        var init = function() {\r\n            if ( initialized ) { return; }\r\n            execPreInitPlugins( root );\r\n\r\n            // First we set up the viewport for mobile devices.\r\n            // For some reason iPad goes nuts when it is not done properly.\r\n            var meta = lib.util.$( \"meta[name='viewport']\" ) || document.createElement( \"meta\" );\r\n            meta.content = \"width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no\";\r\n            if ( meta.parentNode !== document.head ) {\r\n                meta.name = \"viewport\";\r\n                document.head.appendChild( meta );\r\n            }\r\n\r\n            // Initialize configuration object\r\n            var rootData = root.dataset;\r\n            config = {\r\n                width: lib.util.toNumber( rootData.width, defaults.width ),\r\n                height: lib.util.toNumber( rootData.height, defaults.height ),\r\n                maxScale: lib.util.toNumber( rootData.maxScale, defaults.maxScale ),\r\n                minScale: lib.util.toNumber( rootData.minScale, defaults.minScale ),\r\n                perspective: lib.util.toNumber( rootData.perspective, defaults.perspective ),\r\n                transitionDuration: lib.util.toNumber(\r\n                    rootData.transitionDuration, defaults.transitionDuration\r\n                )\r\n            };\r\n\r\n            windowScale = computeWindowScale( config );\r\n\r\n            // Wrap steps with \"canvas\" element\r\n            lib.util.arrayify( root.childNodes ).forEach( function( el ) {\r\n                canvas.appendChild( el );\r\n            } );\r\n            root.appendChild( canvas );\r\n\r\n            // Set initial styles\r\n            document.documentElement.style.height = \"100%\";\r\n\r\n            css( body, {\r\n                height: \"100%\",\r\n                overflow: \"hidden\"\r\n            } );\r\n\r\n            var rootStyles = {\r\n                position: \"absolute\",\r\n                transformOrigin: \"top left\",\r\n                transition: \"all 0s ease-in-out\",\r\n                transformStyle: \"preserve-3d\"\r\n            };\r\n\r\n            css( root, rootStyles );\r\n            css( root, {\r\n                top: \"50%\",\r\n                left: \"50%\",\r\n                perspective: ( config.perspective / windowScale ) + \"px\",\r\n                transform: scale( windowScale )\r\n            } );\r\n            css( canvas, rootStyles );\r\n\r\n            body.classList.remove( \"impress-disabled\" );\r\n            body.classList.add( \"impress-enabled\" );\r\n\r\n            // Get and init steps\r\n            initAllSteps();\r\n\r\n            // Set a default initial state of the canvas\r\n            currentState = {\r\n                translate: { x: 0, y: 0, z: 0 },\r\n                rotate:    { x: 0, y: 0, z: 0, order: \"xyz\" },\r\n                scale:     1\r\n            };\r\n\r\n            initialized = true;\r\n\r\n            lib.util.triggerEvent( root, \"impress:init\",\r\n                                   { api: roots[ \"impress-root-\" + rootId ] } );\r\n        };\r\n\r\n        // `getStep` is a helper function that returns a step element defined by parameter.\r\n        // If a number is given, step with index given by the number is returned, if a string\r\n        // is given step element with such id is returned, if DOM element is given it is returned\r\n        // if it is a correct step element.\r\n        var getStep = function( step ) {\r\n            if ( typeof step === \"number\" ) {\r\n                step = step < 0 ? steps[ steps.length + step ] : steps[ step ];\r\n            } else if ( typeof step === \"string\" ) {\r\n                step = lib.util.byId( step );\r\n            }\r\n            return ( step && step.id && stepsData[ \"impress-\" + step.id ] ) ? step : null;\r\n        };\r\n\r\n        // Used to reset timeout for `impress:stepenter` event\r\n        var stepEnterTimeout = null;\r\n\r\n        // `goto` API function that moves to step given as `el` parameter (by index, id or element).\r\n        // `duration` optionally given as second parameter, is the transition duration in css.\r\n        // `reason` is the string \"next\", \"prev\" or \"goto\" (default) and will be made available to\r\n        // preStepLeave plugins.\r\n        // `origEvent` may contain event that caused the call to goto, such as a key press event\r\n        var goto = function( el, duration, reason, origEvent ) {\r\n            reason = reason || \"goto\";\r\n            origEvent = origEvent || null;\r\n\r\n            if ( !initialized ) {\r\n                return false;\r\n            }\r\n\r\n            // Re-execute initAllSteps for each transition. This allows to edit step attributes\r\n            // dynamically, such as change their coordinates, or even remove or add steps, and have\r\n            // that change apply when goto() is called.\r\n            initAllSteps();\r\n\r\n            if ( !( el = getStep( el ) ) ) {\r\n                return false;\r\n            }\r\n\r\n            // Sometimes it's possible to trigger focus on first link with some keyboard action.\r\n            // Browser in such a case tries to scroll the page to make this element visible\r\n            // (even that body overflow is set to hidden) and it breaks our careful positioning.\r\n            //\r\n            // So, as a lousy (and lazy) workaround we will make the page scroll back to the top\r\n            // whenever slide is selected\r\n            //\r\n            // If you are reading this and know any better way to handle it, I'll be glad to hear\r\n            // about it!\r\n            window.scrollTo( 0, 0 );\r\n\r\n            var step = stepsData[ \"impress-\" + el.id ];\r\n            duration = ( duration !== undefined ? duration : step.transitionDuration );\r\n\r\n            // If we are in fact moving to another step, start with executing the registered\r\n            // preStepLeave plugins.\r\n            if ( activeStep && activeStep !== el ) {\r\n                var event = { target: activeStep, detail: {} };\r\n                event.detail.next = el;\r\n                event.detail.transitionDuration = duration;\r\n                event.detail.reason = reason;\r\n                if ( origEvent ) {\r\n                    event.origEvent = origEvent;\r\n                }\r\n\r\n                if ( execPreStepLeavePlugins( event ) === false ) {\r\n\r\n                    // PreStepLeave plugins are allowed to abort the transition altogether, by\r\n                    // returning false.\r\n                    // see stop and substep plugins for an example of doing just that\r\n                    return false;\r\n                }\r\n\r\n                // Plugins are allowed to change the detail values\r\n                el = event.detail.next;\r\n                step = stepsData[ \"impress-\" + el.id ];\r\n                duration = event.detail.transitionDuration;\r\n            }\r\n\r\n            if ( activeStep ) {\r\n                activeStep.classList.remove( \"active\" );\r\n                body.classList.remove( \"impress-on-\" + activeStep.id );\r\n            }\r\n            el.classList.add( \"active\" );\r\n\r\n            body.classList.add( \"impress-on-\" + el.id );\r\n\r\n            // Compute target state of the canvas based on given step\r\n            var target = {\r\n                rotate: {\r\n                    x: -step.rotate.x,\r\n                    y: -step.rotate.y,\r\n                    z: -step.rotate.z,\r\n                    order: step.rotate.order\r\n                },\r\n                translate: {\r\n                    x: -step.translate.x,\r\n                    y: -step.translate.y,\r\n                    z: -step.translate.z\r\n                },\r\n                scale: 1 / step.scale\r\n            };\r\n\r\n            // Check if the transition is zooming in or not.\r\n            //\r\n            // This information is used to alter the transition style:\r\n            // when we are zooming in - we start with move and rotate transition\r\n            // and the scaling is delayed, but when we are zooming out we start\r\n            // with scaling down and move and rotation are delayed.\r\n            var zoomin = target.scale >= currentState.scale;\r\n\r\n            duration = lib.util.toNumber( duration, config.transitionDuration );\r\n            var delay = ( duration / 2 );\r\n\r\n            // If the same step is re-selected, force computing window scaling,\r\n            // because it is likely to be caused by window resize\r\n            if ( el === activeStep ) {\r\n                windowScale = computeWindowScale( config );\r\n            }\r\n\r\n            var targetScale = target.scale * windowScale;\r\n\r\n            // Trigger leave of currently active element (if it's not the same step again)\r\n            if ( activeStep && activeStep !== el ) {\r\n                onStepLeave( activeStep, el );\r\n            }\r\n\r\n            // Now we alter transforms of `root` and `canvas` to trigger transitions.\r\n            //\r\n            // And here is why there are two elements: `root` and `canvas` - they are\r\n            // being animated separately:\r\n            // `root` is used for scaling and `canvas` for translate and rotations.\r\n            // Transitions on them are triggered with different delays (to make\r\n            // visually nice and \"natural\" looking transitions), so we need to know\r\n            // that both of them are finished.\r\n            css( root, {\r\n\r\n                // To keep the perspective look similar for different scales\r\n                // we need to \"scale\" the perspective, too\r\n                // For IE 11 support we must specify perspective independent\r\n                // of transform.\r\n                perspective: ( config.perspective / targetScale ) + \"px\",\r\n                transform: scale( targetScale ),\r\n                transitionDuration: duration + \"ms\",\r\n                transitionDelay: ( zoomin ? delay : 0 ) + \"ms\"\r\n            } );\r\n\r\n            css( canvas, {\r\n                transform: rotate( target.rotate, true ) + translate( target.translate ),\r\n                transitionDuration: duration + \"ms\",\r\n                transitionDelay: ( zoomin ? 0 : delay ) + \"ms\"\r\n            } );\r\n\r\n            // Here is a tricky part...\r\n            //\r\n            // If there is no change in scale or no change in rotation and translation, it means\r\n            // there was actually no delay - because there was no transition on `root` or `canvas`\r\n            // elements. We want to trigger `impress:stepenter` event in the correct moment, so\r\n            // here we compare the current and target values to check if delay should be taken into\r\n            // account.\r\n            //\r\n            // I know that this `if` statement looks scary, but it's pretty simple when you know\r\n            // what is going on - it's simply comparing all the values.\r\n            if ( currentState.scale === target.scale ||\r\n                ( currentState.rotate.x === target.rotate.x &&\r\n                  currentState.rotate.y === target.rotate.y &&\r\n                  currentState.rotate.z === target.rotate.z &&\r\n                  currentState.translate.x === target.translate.x &&\r\n                  currentState.translate.y === target.translate.y &&\r\n                  currentState.translate.z === target.translate.z ) ) {\r\n                delay = 0;\r\n            }\r\n\r\n            // Store current state\r\n            currentState = target;\r\n            activeStep = el;\r\n\r\n            // And here is where we trigger `impress:stepenter` event.\r\n            // We simply set up a timeout to fire it taking transition duration (and possible delay)\r\n            // into account.\r\n            //\r\n            // I really wanted to make it in more elegant way. The `transitionend` event seemed to\r\n            // be the best way to do it, but the fact that I'm using transitions on two separate\r\n            // elements and that the `transitionend` event is only triggered when there was a\r\n            // transition (change in the values) caused some bugs and made the code really\r\n            // complicated, cause I had to handle all the conditions separately. And it still\r\n            // needed a `setTimeout` fallback for the situations when there is no transition at all.\r\n            // So I decided that I'd rather make the code simpler than use shiny new\r\n            // `transitionend`.\r\n            //\r\n            // If you want learn something interesting and see how it was done with `transitionend`\r\n            // go back to version 0.5.2 of impress.js:\r\n            // http://github.com/bartaz/impress.js/blob/0.5.2/js/impress.js\r\n            window.clearTimeout( stepEnterTimeout );\r\n            stepEnterTimeout = window.setTimeout( function() {\r\n                onStepEnter( activeStep );\r\n            }, duration + delay );\r\n\r\n            return el;\r\n        };\r\n\r\n        // `prev` API function goes to previous step (in document order)\r\n        // `event` is optional, may contain the event that caused the need to call prev()\r\n        var prev = function( origEvent ) {\r\n            var prev = steps.indexOf( activeStep ) - 1;\r\n            prev = prev >= 0 ? steps[ prev ] : steps[ steps.length - 1 ];\r\n\r\n            return goto( prev, undefined, \"prev\", origEvent );\r\n        };\r\n\r\n        // `next` API function goes to next step (in document order)\r\n        // `event` is optional, may contain the event that caused the need to call next()\r\n        var next = function( origEvent ) {\r\n            var next = steps.indexOf( activeStep ) + 1;\r\n            next = next < steps.length ? steps[ next ] : steps[ 0 ];\r\n\r\n            return goto( next, undefined, \"next\", origEvent );\r\n        };\r\n\r\n        // Swipe for touch devices by @and3rson.\r\n        // Below we extend the api to control the animation between the currently\r\n        // active step and a presumed next/prev step. See touch plugin for\r\n        // an example of using this api.\r\n\r\n        // Helper function\r\n        var interpolate = function( a, b, k ) {\r\n            return a + ( b - a ) * k;\r\n        };\r\n\r\n        // Animate a swipe.\r\n        //\r\n        // Pct is a value between -1.0 and +1.0, designating the current length\r\n        // of the swipe.\r\n        //\r\n        // If pct is negative, swipe towards the next() step, if positive,\r\n        // towards the prev() step.\r\n        //\r\n        // Note that pre-stepleave plugins such as goto can mess with what is a\r\n        // next() and prev() step, so we need to trigger the pre-stepleave event\r\n        // here, even if a swipe doesn't guarantee that the transition will\r\n        // actually happen.\r\n        //\r\n        // Calling swipe(), with any value of pct, won't in itself cause a\r\n        // transition to happen, this is just to animate the swipe. Once the\r\n        // transition is committed - such as at a touchend event - caller is\r\n        // responsible for also calling prev()/next() as appropriate.\r\n        //\r\n        // Note: For now, this function is made available to be used by the swipe plugin (which\r\n        // is the UI counterpart to this). It is a semi-internal API and intentionally not\r\n        // documented in DOCUMENTATION.md.\r\n        var swipe = function( pct ) {\r\n            if ( Math.abs( pct ) > 1 ) {\r\n                return;\r\n            }\r\n\r\n            // Prepare & execute the preStepLeave event\r\n            var event = { target: activeStep, detail: {} };\r\n            event.detail.swipe = pct;\r\n\r\n            // Will be ignored within swipe animation, but just in case a plugin wants to read this,\r\n            // humor them\r\n            event.detail.transitionDuration = config.transitionDuration;\r\n            var idx; // Needed by jshint\r\n            if ( pct < 0 ) {\r\n                idx = steps.indexOf( activeStep ) + 1;\r\n                event.detail.next = idx < steps.length ? steps[ idx ] : steps[ 0 ];\r\n                event.detail.reason = \"next\";\r\n            } else if ( pct > 0 ) {\r\n                idx = steps.indexOf( activeStep ) - 1;\r\n                event.detail.next = idx >= 0 ? steps[ idx ] : steps[ steps.length - 1 ];\r\n                event.detail.reason = \"prev\";\r\n            } else {\r\n\r\n                // No move\r\n                return;\r\n            }\r\n            if ( execPreStepLeavePlugins( event ) === false ) {\r\n\r\n                // If a preStepLeave plugin wants to abort the transition, don't animate a swipe\r\n                // For stop, this is probably ok. For substep, the plugin it self might want to do\r\n                // some animation, but that's not the current implementation.\r\n                return false;\r\n            }\r\n            var nextElement = event.detail.next;\r\n\r\n            var nextStep = stepsData[ \"impress-\" + nextElement.id ];\r\n\r\n            // If the same step is re-selected, force computing window scaling,\r\n            var nextScale = nextStep.scale * windowScale;\r\n            var k = Math.abs( pct );\r\n\r\n            var interpolatedStep = {\r\n                translate: {\r\n                    x: interpolate( currentState.translate.x, -nextStep.translate.x, k ),\r\n                    y: interpolate( currentState.translate.y, -nextStep.translate.y, k ),\r\n                    z: interpolate( currentState.translate.z, -nextStep.translate.z, k )\r\n                },\r\n                rotate: {\r\n                    x: interpolate( currentState.rotate.x, -nextStep.rotate.x, k ),\r\n                    y: interpolate( currentState.rotate.y, -nextStep.rotate.y, k ),\r\n                    z: interpolate( currentState.rotate.z, -nextStep.rotate.z, k ),\r\n\r\n                    // Unfortunately there's a discontinuity if rotation order changes. Nothing I\r\n                    // can do about it?\r\n                    order: k < 0.7 ? currentState.rotate.order : nextStep.rotate.order\r\n                },\r\n                scale: interpolate( currentState.scale * windowScale, nextScale, k )\r\n            };\r\n\r\n            css( root, {\r\n\r\n                // To keep the perspective look similar for different scales\r\n                // we need to 'scale' the perspective, too\r\n                perspective: config.perspective / interpolatedStep.scale + \"px\",\r\n                transform: scale( interpolatedStep.scale ),\r\n                transitionDuration: \"0ms\",\r\n                transitionDelay: \"0ms\"\r\n            } );\r\n\r\n            css( canvas, {\r\n                transform: rotate( interpolatedStep.rotate, true ) +\r\n                           translate( interpolatedStep.translate ),\r\n                transitionDuration: \"0ms\",\r\n                transitionDelay: \"0ms\"\r\n            } );\r\n        };\r\n\r\n        // Teardown impress\r\n        // Resets the DOM to the state it was before impress().init() was called.\r\n        // (If you called impress(rootId).init() for multiple different rootId's, then you must\r\n        // also call tear() once for each of them.)\r\n        var tear = function() {\r\n            lib.gc.teardown();\r\n            delete roots[ \"impress-root-\" + rootId ];\r\n        };\r\n\r\n        // Adding some useful classes to step elements.\r\n        //\r\n        // All the steps that have not been shown yet are given `future` class.\r\n        // When the step is entered the `future` class is removed and the `present`\r\n        // class is given. When the step is left `present` class is replaced with\r\n        // `past` class.\r\n        //\r\n        // So every step element is always in one of three possible states:\r\n        // `future`, `present` and `past`.\r\n        //\r\n        // There classes can be used in CSS to style different types of steps.\r\n        // For example the `present` class can be used to trigger some custom\r\n        // animations when step is shown.\r\n        lib.gc.addEventListener( root, \"impress:init\", function() {\r\n\r\n            // STEP CLASSES\r\n            steps.forEach( function( step ) {\r\n                step.classList.add( \"future\" );\r\n            } );\r\n\r\n            lib.gc.addEventListener( root, \"impress:stepenter\", function( event ) {\r\n                event.target.classList.remove( \"past\" );\r\n                event.target.classList.remove( \"future\" );\r\n                event.target.classList.add( \"present\" );\r\n            }, false );\r\n\r\n            lib.gc.addEventListener( root, \"impress:stepleave\", function( event ) {\r\n                event.target.classList.remove( \"present\" );\r\n                event.target.classList.add( \"past\" );\r\n            }, false );\r\n\r\n        }, false );\r\n\r\n        // Adding hash change support.\r\n        lib.gc.addEventListener( root, \"impress:init\", function() {\r\n\r\n            // Last hash detected\r\n            var lastHash = \"\";\r\n\r\n            // `#/step-id` is used instead of `#step-id` to prevent default browser\r\n            // scrolling to element in hash.\r\n            //\r\n            // And it has to be set after animation finishes, because in Chrome it\r\n            // makes transtion laggy.\r\n            // BUG: http://code.google.com/p/chromium/issues/detail?id=62820\r\n            lib.gc.addEventListener( root, \"impress:stepenter\", function( event ) {\r\n                window.location.hash = lastHash = \"#/\" + event.target.id;\r\n            }, false );\r\n\r\n            lib.gc.addEventListener( window, \"hashchange\", function() {\r\n\r\n                // When the step is entered hash in the location is updated\r\n                // (just few lines above from here), so the hash change is\r\n                // triggered and we would call `goto` again on the same element.\r\n                //\r\n                // To avoid this we store last entered hash and compare.\r\n                if ( window.location.hash !== lastHash ) {\r\n                    goto( lib.util.getElementFromHash() );\r\n                }\r\n            }, false );\r\n\r\n            // START\r\n            // by selecting step defined in url or first step of the presentation\r\n            goto( lib.util.getElementFromHash() || steps[ 0 ], 0 );\r\n        }, false );\r\n\r\n        body.classList.add( \"impress-disabled\" );\r\n\r\n        // Store and return API for given impress.js root element\r\n        return ( roots[ \"impress-root-\" + rootId ] = {\r\n            init: init,\r\n            goto: goto,\r\n            next: next,\r\n            prev: prev,\r\n            swipe: swipe,\r\n            tear: tear,\r\n            lib: lib\r\n        } );\r\n\r\n    };\r\n\r\n    // Flag that can be used in JS to check if browser have passed the support test\r\n    impress.supported = impressSupported;\r\n\r\n    // ADD and INIT LIBRARIES\r\n    // Library factories are defined in src/lib/*.js, and register themselves by calling\r\n    // impress.addLibraryFactory(libraryFactoryObject). They're stored here, and used to augment\r\n    // the API with library functions when client calls impress(rootId).\r\n    // See src/lib/README.md for clearer example.\r\n    // (Advanced usage: For different values of rootId, a different instance of the libaries are\r\n    // generated, in case they need to hold different state for different root elements.)\r\n    var libraryFactories = {};\r\n    impress.addLibraryFactory = function( obj ) {\r\n        for ( var libname in obj ) {\r\n            if ( obj.hasOwnProperty( libname ) ) {\r\n                libraryFactories[ libname ] = obj[ libname ];\r\n            }\r\n        }\r\n    };\r\n\r\n    // Call each library factory, and return the lib object that is added to the api.\r\n    var initLibraries = function( rootId ) { //jshint ignore:line\r\n        var lib = {};\r\n        for ( var libname in libraryFactories ) {\r\n            if ( libraryFactories.hasOwnProperty( libname ) ) {\r\n                if ( lib[ libname ] !== undefined ) {\r\n                    throw \"impress.js ERROR: Two libraries both tried to use libname: \" +  libname;\r\n                }\r\n                lib[ libname ] = libraryFactories[ libname ]( rootId );\r\n            }\r\n        }\r\n        return lib;\r\n    };\r\n\r\n    // `addPreInitPlugin` allows plugins to register a function that should\r\n    // be run (synchronously) at the beginning of init, before\r\n    // impress().init() itself executes.\r\n    impress.addPreInitPlugin = function( plugin, weight ) {\r\n        weight = parseInt( weight ) || 10;\r\n        if ( weight <= 0 ) {\r\n            throw \"addPreInitPlugin: weight must be a positive integer\";\r\n        }\r\n\r\n        if ( preInitPlugins[ weight ] === undefined ) {\r\n            preInitPlugins[ weight ] = [];\r\n        }\r\n        preInitPlugins[ weight ].push( plugin );\r\n    };\r\n\r\n    // Called at beginning of init, to execute all pre-init plugins.\r\n    var execPreInitPlugins = function( root ) { //jshint ignore:line\r\n        for ( var i = 0; i < preInitPlugins.length; i++ ) {\r\n            var thisLevel = preInitPlugins[ i ];\r\n            if ( thisLevel !== undefined ) {\r\n                for ( var j = 0; j < thisLevel.length; j++ ) {\r\n                    thisLevel[ j ]( root );\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // `addPreStepLeavePlugin` allows plugins to register a function that should\r\n    // be run (synchronously) at the beginning of goto()\r\n    impress.addPreStepLeavePlugin = function( plugin, weight ) { //jshint ignore:line\r\n        weight = parseInt( weight ) || 10;\r\n        if ( weight <= 0 ) {\r\n            throw \"addPreStepLeavePlugin: weight must be a positive integer\";\r\n        }\r\n\r\n        if ( preStepLeavePlugins[ weight ] === undefined ) {\r\n            preStepLeavePlugins[ weight ] = [];\r\n        }\r\n        preStepLeavePlugins[ weight ].push( plugin );\r\n    };\r\n\r\n    // Called at beginning of goto(), to execute all preStepLeave plugins.\r\n    var execPreStepLeavePlugins = function( event ) { //jshint ignore:line\r\n        for ( var i = 0; i < preStepLeavePlugins.length; i++ ) {\r\n            var thisLevel = preStepLeavePlugins[ i ];\r\n            if ( thisLevel !== undefined ) {\r\n                for ( var j = 0; j < thisLevel.length; j++ ) {\r\n                    if ( thisLevel[ j ]( event ) === false ) {\r\n\r\n                        // If a plugin returns false, the stepleave event (and related transition)\r\n                        // is aborted\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n} )( document, window );\r\n\r\n// THAT'S ALL FOLKS!\r\n//\r\n// Thanks for reading it all.\r\n// Or thanks for scrolling down and reading the last part.\r\n//\r\n// I've learnt a lot when building impress.js and I hope this code and comments\r\n// will help somebody learn at least some part of it.\r\n\r\n/**\r\n * Garbage collection utility\r\n *\r\n * This library allows plugins to add elements and event listeners they add to the DOM. The user\r\n * can call `impress().lib.gc.teardown()` to cause all of them to be removed from DOM, so that\r\n * the document is in the state it was before calling `impress().init()`.\r\n *\r\n * In addition to just adding elements and event listeners to the garbage collector, plugins\r\n * can also register callback functions to do arbitrary cleanup upon teardown.\r\n *\r\n * Henrik Ingo (c) 2016\r\n * MIT License\r\n */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var roots = [];\r\n    var rootsCount = 0;\r\n    var startingState = { roots: [] };\r\n\r\n    var libraryFactory = function( rootId ) {\r\n        if ( roots[ rootId ] ) {\r\n            return roots[ rootId ];\r\n        }\r\n\r\n        // Per root global variables (instance variables?)\r\n        var elementList = [];\r\n        var eventListenerList = [];\r\n        var callbackList = [];\r\n\r\n        recordStartingState( rootId );\r\n\r\n        // LIBRARY FUNCTIONS\r\n        // Definitions of the library functions we return as an object at the end\r\n\r\n        // `pushElement` adds a DOM element to the gc stack\r\n        var pushElement = function( element ) {\r\n            elementList.push( element );\r\n        };\r\n\r\n        // `appendChild` is a convenience wrapper that combines DOM appendChild with gc.pushElement\r\n        var appendChild = function( parent, element ) {\r\n            parent.appendChild( element );\r\n            pushElement( element );\r\n        };\r\n\r\n        // `pushEventListener` adds an event listener to the gc stack\r\n        var pushEventListener = function( target, type, listenerFunction ) {\r\n            eventListenerList.push( { target:target, type:type, listener:listenerFunction } );\r\n        };\r\n\r\n        // `addEventListener` combines DOM addEventListener with gc.pushEventListener\r\n        var addEventListener = function( target, type, listenerFunction ) {\r\n            target.addEventListener( type, listenerFunction );\r\n            pushEventListener( target, type, listenerFunction );\r\n        };\r\n\r\n        // `pushCallback` If the above utilities are not enough, plugins can add their own callback\r\n        // function to do arbitrary things.\r\n        var pushCallback = function( callback ) {\r\n            callbackList.push( callback );\r\n        };\r\n        pushCallback( function( rootId ) { resetStartingState( rootId ); } );\r\n\r\n        // `teardown` will\r\n        // - execute all callbacks in LIFO order\r\n        // - call `removeChild` on all DOM elements in LIFO order\r\n        // - call `removeEventListener` on all event listeners in LIFO order\r\n        // The goal of a teardown is to return to the same state that the DOM was before\r\n        // `impress().init()` was called.\r\n        var teardown = function() {\r\n\r\n            // Execute the callbacks in LIFO order\r\n            var i; // Needed by jshint\r\n            for ( i = callbackList.length - 1; i >= 0; i-- ) {\r\n                callbackList[ i ]( rootId );\r\n            }\r\n            callbackList = [];\r\n            for ( i = 0; i < elementList.length; i++ ) {\r\n                elementList[ i ].parentElement.removeChild( elementList[ i ] );\r\n            }\r\n            elementList = [];\r\n            for ( i = 0; i < eventListenerList.length; i++ ) {\r\n                var target   = eventListenerList[ i ].target;\r\n                var type     = eventListenerList[ i ].type;\r\n                var listener = eventListenerList[ i ].listener;\r\n                target.removeEventListener( type, listener );\r\n            }\r\n        };\r\n\r\n        var lib = {\r\n            pushElement: pushElement,\r\n            appendChild: appendChild,\r\n            pushEventListener: pushEventListener,\r\n            addEventListener: addEventListener,\r\n            pushCallback: pushCallback,\r\n            teardown: teardown\r\n        };\r\n        roots[ rootId ] = lib;\r\n        rootsCount++;\r\n        return lib;\r\n    };\r\n\r\n    // Let impress core know about the existence of this library\r\n    window.impress.addLibraryFactory( { gc: libraryFactory } );\r\n\r\n    // CORE INIT\r\n    // The library factory (gc(rootId)) is called at the beginning of impress(rootId).init()\r\n    // For the purposes of teardown(), we can use this as an opportunity to save the state\r\n    // of a few things in the DOM in their virgin state, before impress().init() did anything.\r\n    // Note: These could also be recorded by the code in impress.js core as these values\r\n    // are changed, but in an effort to not deviate too much from upstream, I'm adding\r\n    // them here rather than the core itself.\r\n    var recordStartingState = function( rootId ) {\r\n        startingState.roots[ rootId ] = {};\r\n        startingState.roots[ rootId ].steps = [];\r\n\r\n        // Record whether the steps have an id or not\r\n        var steps = document.getElementById( rootId ).querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            var el = steps[ i ];\r\n            startingState.roots[ rootId ].steps.push( {\r\n                el: el,\r\n                id: el.getAttribute( \"id\" )\r\n            } );\r\n        }\r\n\r\n        // In the rare case of multiple roots, the following is changed on first init() and\r\n        // reset at last tear().\r\n        if ( rootsCount === 0 ) {\r\n            startingState.body = {};\r\n\r\n            // It is customary for authors to set body.class=\"impress-not-supported\" as a starting\r\n            // value, which can then be removed by impress().init(). But it is not required.\r\n            // Remember whether it was there or not.\r\n            if ( document.body.classList.contains( \"impress-not-supported\" ) ) {\r\n                startingState.body.impressNotSupported = true;\r\n            } else {\r\n                startingState.body.impressNotSupported = false;\r\n            }\r\n\r\n            // If there's a <meta name=\"viewport\"> element, its contents will be overwritten by init\r\n            var metas = document.head.querySelectorAll( \"meta\" );\r\n            for ( i = 0; i < metas.length; i++ ) {\r\n                var m = metas[ i ];\r\n                if ( m.name === \"viewport\" ) {\r\n                    startingState.meta = m.content;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // CORE TEARDOWN\r\n    var resetStartingState = function( rootId ) {\r\n\r\n        // Reset body element\r\n        document.body.classList.remove( \"impress-enabled\" );\r\n        document.body.classList.remove( \"impress-disabled\" );\r\n\r\n        var root = document.getElementById( rootId );\r\n        var activeId = root.querySelector( \".active\" ).id;\r\n        document.body.classList.remove( \"impress-on-\" + activeId );\r\n\r\n        document.documentElement.style.height = \"\";\r\n        document.body.style.height = \"\";\r\n        document.body.style.overflow = \"\";\r\n\r\n        // Remove style values from the root and step elements\r\n        // Note: We remove the ones set by impress.js core. Otoh, we didn't preserve any original\r\n        // values. A more sophisticated implementation could keep track of original values and then\r\n        // reset those.\r\n        var steps = root.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            steps[ i ].classList.remove( \"future\" );\r\n            steps[ i ].classList.remove( \"past\" );\r\n            steps[ i ].classList.remove( \"present\" );\r\n            steps[ i ].classList.remove( \"active\" );\r\n            steps[ i ].style.position = \"\";\r\n            steps[ i ].style.transform = \"\";\r\n            steps[ i ].style[ \"transform-style\" ] = \"\";\r\n        }\r\n        root.style.position = \"\";\r\n        root.style[ \"transform-origin\" ] = \"\";\r\n        root.style.transition = \"\";\r\n        root.style[ \"transform-style\" ] = \"\";\r\n        root.style.top = \"\";\r\n        root.style.left = \"\";\r\n        root.style.transform = \"\";\r\n\r\n        // Reset id of steps (\"step-1\" id's are auto generated)\r\n        steps = startingState.roots[ rootId ].steps;\r\n        var step;\r\n        while ( step = steps.pop() ) {\r\n            if ( step.id === null ) {\r\n                step.el.removeAttribute( \"id\" );\r\n            } else {\r\n                step.el.setAttribute( \"id\", step.id );\r\n            }\r\n        }\r\n        delete startingState.roots[ rootId ];\r\n\r\n        // Move step div elements away from canvas, then delete canvas\r\n        // Note: There's an implicit assumption here that the canvas div is the only child element\r\n        // of the root div. If there would be something else, it's gonna be lost.\r\n        var canvas = root.firstChild;\r\n        var canvasHTML = canvas.innerHTML;\r\n        root.innerHTML = canvasHTML;\r\n\r\n        if ( roots[ rootId ] !== undefined ) {\r\n            delete roots[ rootId ];\r\n            rootsCount--;\r\n        }\r\n        if ( rootsCount === 0 ) {\r\n\r\n            // In the rare case that more than one impress root elements were initialized, these\r\n            // are only reset when all are uninitialized.\r\n            document.body.classList.remove( \"impress-supported\" );\r\n            if ( startingState.body.impressNotSupported ) {\r\n                document.body.classList.add( \"impress-not-supported\" );\r\n            }\r\n\r\n            // We need to remove or reset the meta element inserted by impress.js\r\n            var metas = document.head.querySelectorAll( \"meta\" );\r\n            for ( i = 0; i < metas.length; i++ ) {\r\n                var m = metas[ i ];\r\n                if ( m.name === \"viewport\" ) {\r\n                    if ( startingState.meta !== undefined ) {\r\n                        m.content = startingState.meta;\r\n                    } else {\r\n                        m.parentElement.removeChild( m );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Common utility functions\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Henrik Ingo (c) 2016\r\n * MIT License\r\n */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var roots = [];\r\n\r\n    var libraryFactory = function( rootId ) {\r\n        if ( roots[ rootId ] ) {\r\n            return roots[ rootId ];\r\n        }\r\n\r\n        // `$` returns first element for given CSS `selector` in the `context` of\r\n        // the given element or whole document.\r\n        var $ = function( selector, context ) {\r\n            context = context || document;\r\n            return context.querySelector( selector );\r\n        };\r\n\r\n        // `$$` return an array of elements for given CSS `selector` in the `context` of\r\n        // the given element or whole document.\r\n        var $$ = function( selector, context ) {\r\n            context = context || document;\r\n            return arrayify( context.querySelectorAll( selector ) );\r\n        };\r\n\r\n        // `arrayify` takes an array-like object and turns it into real Array\r\n        // to make all the Array.prototype goodness available.\r\n        var arrayify = function( a ) {\r\n            return [].slice.call( a );\r\n        };\r\n\r\n        // `byId` returns element with given `id` - you probably have guessed that ;)\r\n        var byId = function( id ) {\r\n            return document.getElementById( id );\r\n        };\r\n\r\n        // `getElementFromHash` returns an element located by id from hash part of\r\n        // window location.\r\n        var getElementFromHash = function() {\r\n\r\n            // Get id from url # by removing `#` or `#/` from the beginning,\r\n            // so both \"fallback\" `#slide-id` and \"enhanced\" `#/slide-id` will work\r\n            return byId( window.location.hash.replace( /^#\\/?/, \"\" ) );\r\n        };\r\n\r\n        // Throttling function calls, by Remy Sharp\r\n        // http://remysharp.com/2010/07/21/throttling-function-calls/\r\n        var throttle = function( fn, delay ) {\r\n            var timer = null;\r\n            return function() {\r\n                var context = this, args = arguments;\r\n                window.clearTimeout( timer );\r\n                timer = window.setTimeout( function() {\r\n                    fn.apply( context, args );\r\n                }, delay );\r\n            };\r\n        };\r\n\r\n        // `toNumber` takes a value given as `numeric` parameter and tries to turn\r\n        // it into a number. If it is not possible it returns 0 (or other value\r\n        // given as `fallback`).\r\n        var toNumber = function( numeric, fallback ) {\r\n            return isNaN( numeric ) ? ( fallback || 0 ) : Number( numeric );\r\n        };\r\n\r\n        // `triggerEvent` builds a custom DOM event with given `eventName` and `detail` data\r\n        // and triggers it on element given as `el`.\r\n        var triggerEvent = function( el, eventName, detail ) {\r\n            var event = document.createEvent( \"CustomEvent\" );\r\n            event.initCustomEvent( eventName, true, true, detail );\r\n            el.dispatchEvent( event );\r\n        };\r\n\r\n        var lib = {\r\n            $: $,\r\n            $$: $$,\r\n            arrayify: arrayify,\r\n            byId: byId,\r\n            getElementFromHash: getElementFromHash,\r\n            throttle: throttle,\r\n            toNumber: toNumber,\r\n            triggerEvent: triggerEvent\r\n        };\r\n        roots[ rootId ] = lib;\r\n        return lib;\r\n    };\r\n\r\n    // Let impress core know about the existence of this library\r\n    window.impress.addLibraryFactory( { util: libraryFactory } );\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Autoplay plugin - Automatically advance slideshow after N seconds\r\n *\r\n * Copyright 2016 Henrik Ingo, henrik.ingo@avoinelama.fi\r\n * Released under the MIT license.\r\n */\r\n/* global clearTimeout, setTimeout, document */\r\n\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    var autoplayDefault = 0;\r\n    var currentStepTimeout = 0;\r\n    var api = null;\r\n    var timeoutHandle = null;\r\n    var root = null;\r\n    var util;\r\n\r\n    // On impress:init, check whether there is a default setting, as well as\r\n    // handle step-1.\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        util = event.detail.api.lib.util;\r\n\r\n        // Getting API from event data instead of global impress().init().\r\n        // You don't even need to know what is the id of the root element\r\n        // or anything. `impress:init` event data gives you everything you\r\n        // need to control the presentation that was just initialized.\r\n        api = event.detail.api;\r\n        root = event.target;\r\n\r\n        // Element attributes starting with \"data-\", become available under\r\n        // element.dataset. In addition hyphenized words become camelCased.\r\n        var data = root.dataset;\r\n\r\n        if ( data.autoplay ) {\r\n            autoplayDefault = util.toNumber( data.autoplay, 0 );\r\n        }\r\n\r\n        var toolbar = document.querySelector( \"#impress-toolbar\" );\r\n        if ( toolbar ) {\r\n            addToolbarButton( toolbar );\r\n        }\r\n\r\n        api.lib.gc.pushCallback( function() {\r\n            clearTimeout( timeoutHandle );\r\n        } );\r\n\r\n        // Note that right after impress:init event, also impress:stepenter is\r\n        // triggered for the first slide, so that's where code flow continues.\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:autoplay:pause\", function( event ) {\r\n        status = \"paused\";\r\n        reloadTimeout( event );\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:autoplay:play\", function( event ) {\r\n        status = \"playing\";\r\n        reloadTimeout( event );\r\n    }, false );\r\n\r\n    // If default autoplay time was defined in the presentation root, or\r\n    // in this step, set timeout.\r\n    var reloadTimeout = function( event ) {\r\n        var step = event.target;\r\n        currentStepTimeout = util.toNumber( step.dataset.autoplay, autoplayDefault );\r\n        if ( status === \"paused\" ) {\r\n            setAutoplayTimeout( 0 );\r\n        } else {\r\n            setAutoplayTimeout( currentStepTimeout );\r\n        }\r\n    };\r\n\r\n    document.addEventListener( \"impress:stepenter\", function( event ) {\r\n        reloadTimeout( event );\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:substep:enter\", function( event ) {\r\n        reloadTimeout( event );\r\n    }, false );\r\n\r\n    /**\r\n     * Set timeout after which we move to next() step.\r\n     */\r\n    var setAutoplayTimeout = function( timeout ) {\r\n        if ( timeoutHandle ) {\r\n            clearTimeout( timeoutHandle );\r\n        }\r\n\r\n        if ( timeout > 0 ) {\r\n            timeoutHandle = setTimeout( function() { api.next(); }, timeout * 1000 );\r\n        }\r\n        setButtonText();\r\n    };\r\n\r\n    /*** Toolbar plugin integration *******************************************/\r\n    var status = \"not clicked\";\r\n    var toolbarButton = null;\r\n\r\n    var makeDomElement = function( html ) {\r\n        var tempDiv = document.createElement( \"div\" );\r\n        tempDiv.innerHTML = html;\r\n        return tempDiv.firstChild;\r\n    };\r\n\r\n    var toggleStatus = function() {\r\n        if ( currentStepTimeout > 0 && status !== \"paused\" ) {\r\n            status = \"paused\";\r\n        } else {\r\n            status = \"playing\";\r\n        }\r\n    };\r\n\r\n    var getButtonText = function() {\r\n        if ( currentStepTimeout > 0 && status !== \"paused\" ) {\r\n            return \"||\"; // Pause\r\n        } else {\r\n            return \"&#9654;\"; // Play\r\n        }\r\n    };\r\n\r\n    var setButtonText = function() {\r\n        if ( toolbarButton ) {\r\n\r\n            // Keep button size the same even if label content is changing\r\n            var buttonWidth = toolbarButton.offsetWidth;\r\n            var buttonHeight = toolbarButton.offsetHeight;\r\n            toolbarButton.innerHTML = getButtonText();\r\n            if ( !toolbarButton.style.width ) {\r\n                toolbarButton.style.width = buttonWidth + \"px\";\r\n            }\r\n            if ( !toolbarButton.style.height ) {\r\n                toolbarButton.style.height = buttonHeight + \"px\";\r\n            }\r\n        }\r\n    };\r\n\r\n    var addToolbarButton = function( toolbar ) {\r\n        var html = '<button id=\"impress-autoplay-playpause\" ' + // jshint ignore:line\r\n                   'title=\"Autoplay\" class=\"impress-autoplay\">' + // jshint ignore:line\r\n                   getButtonText() + \"</button>\"; // jshint ignore:line\r\n        toolbarButton = makeDomElement( html );\r\n        toolbarButton.addEventListener( \"click\", function() {\r\n            toggleStatus();\r\n            if ( status === \"playing\" ) {\r\n                if ( autoplayDefault === 0 ) {\r\n                    autoplayDefault = 7;\r\n                }\r\n                if ( currentStepTimeout === 0 ) {\r\n                    currentStepTimeout = autoplayDefault;\r\n                }\r\n                setAutoplayTimeout( currentStepTimeout );\r\n            } else if ( status === \"paused\" ) {\r\n                setAutoplayTimeout( 0 );\r\n            }\r\n        } );\r\n\r\n        util.triggerEvent( toolbar, \"impress:toolbar:appendChild\",\r\n                      { group: 10, element: toolbarButton } );\r\n    };\r\n\r\n} )( document );\r\n\r\n/**\r\n * Blackout plugin\r\n *\r\n * Press b or . to hide all slides, and b or . again to show them.\r\n * Also navigating to a different slide will show them again (impress:stepleave).\r\n *\r\n * Copyright 2014 @Strikeskids\r\n * Released under the MIT license.\r\n */\r\n/* global document */\r\n\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    var canvas = null;\r\n    var blackedOut = false;\r\n    var util = null;\r\n    var root = null;\r\n    var api = null;\r\n\r\n    // While waiting for a shared library of utilities, copying these 2 from main impress.js\r\n    var css = function( el, props ) {\r\n        var key, pkey;\r\n        for ( key in props ) {\r\n            if ( props.hasOwnProperty( key ) ) {\r\n                pkey = pfx( key );\r\n                if ( pkey !== null ) {\r\n                    el.style[ pkey ] = props[ key ];\r\n                }\r\n            }\r\n        }\r\n        return el;\r\n    };\r\n\r\n    var pfx = ( function() {\r\n\r\n        var style = document.createElement( \"dummy\" ).style,\r\n            prefixes = \"Webkit Moz O ms Khtml\".split( \" \" ),\r\n            memory = {};\r\n\r\n        return function( prop ) {\r\n            if ( typeof memory[ prop ] === \"undefined\" ) {\r\n\r\n                var ucProp  = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),\r\n                    props   = ( prop + \" \" + prefixes.join( ucProp + \" \" ) + ucProp ).split( \" \" );\r\n\r\n                memory[ prop ] = null;\r\n                for ( var i in props ) {\r\n                    if ( style[ props[ i ] ] !== undefined ) {\r\n                        memory[ prop ] = props[ i ];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            return memory[ prop ];\r\n        };\r\n\r\n    } )();\r\n\r\n    var removeBlackout = function() {\r\n        if ( blackedOut ) {\r\n            css( canvas, {\r\n                display: \"block\"\r\n            } );\r\n            blackedOut = false;\r\n            util.triggerEvent( root, \"impress:autoplay:play\", {} );\r\n        }\r\n    };\r\n\r\n    var blackout = function() {\r\n        if ( blackedOut ) {\r\n            removeBlackout();\r\n        } else {\r\n            css( canvas, {\r\n                display: ( blackedOut = !blackedOut ) ? \"none\" : \"block\"\r\n            } );\r\n            blackedOut = true;\r\n            util.triggerEvent( root, \"impress:autoplay:pause\", {} );\r\n        }\r\n    };\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        api = event.detail.api;\r\n        util = api.lib.util;\r\n        root = event.target;\r\n        canvas = root.firstElementChild;\r\n        var gc = api.lib.gc;\r\n        var util = api.lib.util;\r\n\r\n        gc.addEventListener( document, \"keydown\", function( event ) {\r\n\r\n            // Accept b or . -> . is sent by presentation remote controllers\r\n            if ( event.keyCode === 66 || event.keyCode === 190 ) {\r\n                event.preventDefault();\r\n                if ( !blackedOut ) {\r\n                    blackout();\r\n                } else {\r\n                    removeBlackout();\r\n                }\r\n            }\r\n        }, false );\r\n\r\n        gc.addEventListener( document, \"keyup\", function( event ) {\r\n\r\n            // Accept b or . -> . is sent by presentation remote controllers\r\n            if ( event.keyCode === 66 || event.keyCode === 190 ) {\r\n                event.preventDefault();\r\n            }\r\n        }, false );\r\n\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:stepleave\", function() {\r\n        removeBlackout();\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\r\n/**\r\n * Extras Plugin\r\n *\r\n * This plugin performs initialization (like calling mermaid.initialize())\r\n * for the extras/ plugins if they are loaded into a presentation.\r\n *\r\n * See README.md for details.\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n/* global markdown, hljs, mermaid, impress, document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    var preInit = function() {\r\n        if ( window.markdown ) {\r\n\r\n            // Unlike the other extras, Markdown.js doesn't by default do anything in\r\n            // particular. We do it ourselves here.\r\n            // In addition, we use \"-----\" as a delimiter for new slide.\r\n\r\n            // Query all .markdown elements and translate to HTML\r\n            var markdownDivs = document.querySelectorAll( \".markdown\" );\r\n            for ( var idx = 0; idx < markdownDivs.length; idx++ ) {\r\n              var element = markdownDivs[ idx ];\r\n\r\n              var slides = element.textContent.split( /^-----$/m );\r\n              var i = slides.length - 1;\r\n              element.innerHTML = markdown.toHTML( slides[ i ] );\r\n\r\n              // If there's an id, unset it for last, and all other, elements,\r\n              // and then set it for the first.\r\n              var id = null;\r\n              if ( element.id ) {\r\n                id = element.id;\r\n                element.id = \"\";\r\n              }\r\n              i--;\r\n              while ( i >= 0 ) {\r\n                var newElement = element.cloneNode( false );\r\n                newElement.innerHTML = markdown.toHTML( slides[ i ] );\r\n                element.parentNode.insertBefore( newElement, element );\r\n                element = newElement;\r\n                i--;\r\n              }\r\n              if ( id !== null ) {\r\n                element.id = id;\r\n              }\r\n            }\r\n        } // Markdown\r\n\r\n        if ( window.hljs ) {\r\n            hljs.initHighlightingOnLoad();\r\n        }\r\n\r\n        if ( window.mermaid ) {\r\n            mermaid.initialize( { startOnLoad:true } );\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-init phase\r\n    // Note: Markdown.js should run early/first, because it creates new div elements.\r\n    // So add this with a lower-than-default weight.\r\n    impress.addPreInitPlugin( preInit, 1 );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Form support\r\n *\r\n * Functionality to better support use of input, textarea, button... elements in a presentation.\r\n *\r\n * This plugin does two things:\r\n *\r\n * Set stopPropagation on any element that might take text input. This allows users to type, for\r\n * example, the letter 'P' into a form field, without causing the presenter console to spring up.\r\n *\r\n * On impress:stepleave, de-focus any potentially active\r\n * element. This is to prevent the focus from being left in a form element that is no longer visible\r\n * in the window, and user therefore typing garbage into the form.\r\n *\r\n * TODO: Currently it is not possible to use TAB to navigate between form elements. Impress.js, and\r\n * in particular the navigation plugin, unfortunately must fully take control of the tab key,\r\n * otherwise a user could cause the browser to scroll to a link or button that's not on the current\r\n * step. However, it could be possible to allow tab navigation between form elements, as long as\r\n * they are on the active step. This is a topic for further study.\r\n *\r\n * Copyright 2016 Henrik Ingo\r\n * MIT License\r\n */\r\n/* global document */\r\n( function( document ) {\r\n    \"use strict\";\r\n    var root;\r\n    var api;\r\n\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        root = event.target;\r\n        api = event.detail.api;\r\n        var gc = api.lib.gc;\r\n\r\n        var selectors = [ \"input\", \"textarea\", \"select\", \"[contenteditable=true]\" ];\r\n        for ( var selector of selectors ) {\r\n            var elements = document.querySelectorAll( selector );\r\n            if ( !elements ) {\r\n                continue;\r\n            }\r\n\r\n            for ( var i = 0; i < elements.length; i++ ) {\r\n                var e = elements[ i ];\r\n                gc.addEventListener( e, \"keydown\", function( event ) {\r\n                    event.stopPropagation();\r\n                } );\r\n                gc.addEventListener( e, \"keyup\", function( event ) {\r\n                    event.stopPropagation();\r\n                } );\r\n            }\r\n        }\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:stepleave\", function() {\r\n        document.activeElement.blur();\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\r\n/**\r\n * Fullscreen plugin\r\n *\r\n * Press F5 to enter fullscreen and ESC to exit fullscreen mode.\r\n *\r\n * Copyright 2019 @giflw\r\n * Released under the MIT license.\r\n */\r\n/* global document */\r\n\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    function enterFullscreen() {\r\n        var elem = document.documentElement;\r\n        if ( !document.fullscreenElement ) {\r\n            elem.requestFullscreen();\r\n        }\r\n    }\r\n\r\n    function exitFullscreen() {\r\n        if ( document.fullscreenElement ) {\r\n            document.exitFullscreen();\r\n        }\r\n    }\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var api = event.detail.api;\r\n        var root = event.target;\r\n        var gc = api.lib.gc;\r\n        var util = api.lib.util;\r\n\r\n        gc.addEventListener( document, \"keydown\", function( event ) {\r\n\r\n            // 116 (F5) is sent by presentation remote controllers\r\n            if ( event.code === \"F5\" ) {\r\n                event.preventDefault();\r\n                enterFullscreen();\r\n                util.triggerEvent( root.querySelector( \".active\" ), \"impress:steprefresh\" );\r\n            }\r\n\r\n            // 27 (Escape) is sent by presentation remote controllers\r\n            if ( event.key === \"Escape\" || event.key === \"F5\" ) {\r\n                event.preventDefault();\r\n                exitFullscreen();\r\n                util.triggerEvent( root.querySelector( \".active\" ), \"impress:steprefresh\" );\r\n            }\r\n        }, false );\r\n\r\n        util.triggerEvent( document, \"impress:help:add\",\r\n            { command: \"F5 / ESC\", text: \"Fullscreen: Enter / Exit\", row: 200 } );\r\n\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\r\n/**\r\n * Goto Plugin\r\n *\r\n * The goto plugin is a pre-stepleave plugin. It is executed before impress:stepleave,\r\n * and will alter the destination where to transition next.\r\n *\r\n * Example:\r\n *\r\n *         <!-- When leaving this step, go directly to \"step-5\" -->\r\n *         <div class=\"step\" data-goto=\"step-5\">\r\n *\r\n *         <!-- When leaving this step with next(), go directly to \"step-5\", instead of next step.\r\n *              If moving backwards to previous step - e.g. prev() instead of next() -\r\n *              then go to \"step-1\". -->\r\n *         <div class=\"step\" data-goto-next=\"step-5\" data-goto-prev=\"step-1\">\r\n *\r\n *        <!-- data-goto-key-list and data-goto-next-list allow you to build advanced non-linear\r\n *             navigation. -->\r\n *        <div class=\"step\"\r\n *             data-goto-key-list=\"ArrowUp ArrowDown ArrowRight ArrowLeft\"\r\n *             data-goto-next-list=\"step-4 step-3 step-2 step-5\">\r\n *\r\n * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for a table\r\n * of what strings to use for each key.\r\n *\r\n * Copyright 2016-2017 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n/* global window, document, impress */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var lib;\r\n\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        lib = event.detail.api.lib;\r\n    }, false );\r\n\r\n    var isNumber = function( numeric ) {\r\n        return !isNaN( numeric );\r\n    };\r\n\r\n    var goto = function( event ) {\r\n        if ( ( !event ) || ( !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        var data = event.target.dataset;\r\n        var steps = document.querySelectorAll( \".step\" );\r\n\r\n        // Data-goto-key-list=\"\" & data-goto-next-list=\"\" //////////////////////////////////////////\r\n        if ( data.gotoKeyList !== undefined &&\r\n             data.gotoNextList !== undefined &&\r\n             event.origEvent !== undefined &&\r\n             event.origEvent.key !== undefined ) {\r\n            var keylist = data.gotoKeyList.split( \" \" );\r\n            var nextlist = data.gotoNextList.split( \" \" );\r\n\r\n            if ( keylist.length !== nextlist.length ) {\r\n                window.console.log(\r\n                    \"impress goto plugin: data-goto-key-list and data-goto-next-list don't match:\"\r\n                );\r\n                window.console.log( keylist );\r\n                window.console.log( nextlist );\r\n\r\n                // Don't return, allow the other categories to work despite this error\r\n            } else {\r\n                var index = keylist.indexOf( event.origEvent.key );\r\n                if ( index >= 0 ) {\r\n                    var next = nextlist[ index ];\r\n                    if ( isNumber( next ) ) {\r\n                        event.detail.next = steps[ next ];\r\n\r\n                        // If the new next element has its own transitionDuration, we're responsible\r\n                        // for setting that on the event as well\r\n                        event.detail.transitionDuration = lib.util.toNumber(\r\n                            event.detail.next.dataset.transitionDuration,\r\n                            event.detail.transitionDuration\r\n                        );\r\n                        return;\r\n                    } else {\r\n                        var newTarget = document.getElementById( next );\r\n                        if ( newTarget && newTarget.classList.contains( \"step\" ) ) {\r\n                            event.detail.next = newTarget;\r\n                            event.detail.transitionDuration = lib.util.toNumber(\r\n                                event.detail.next.dataset.transitionDuration,\r\n                                event.detail.transitionDuration\r\n                            );\r\n                            return;\r\n                        } else {\r\n                            window.console.log( \"impress goto plugin: \" + next +\r\n                                                \" is not a step in this impress presentation.\" );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Data-goto-next=\"\" & data-goto-prev=\"\" ///////////////////////////////////////////////////\r\n\r\n        // Handle event.target data-goto-next attribute\r\n        if ( isNumber( data.gotoNext ) && event.detail.reason === \"next\" ) {\r\n            event.detail.next = steps[ data.gotoNext ];\r\n\r\n            // If the new next element has its own transitionDuration, we're responsible for setting\r\n            // that on the event as well\r\n            event.detail.transitionDuration = lib.util.toNumber(\r\n                event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n            );\r\n            return;\r\n        }\r\n        if ( data.gotoNext && event.detail.reason === \"next\" ) {\r\n            var newTarget = document.getElementById( data.gotoNext ); // jshint ignore:line\r\n            if ( newTarget && newTarget.classList.contains( \"step\" ) ) {\r\n                event.detail.next = newTarget;\r\n                event.detail.transitionDuration = lib.util.toNumber(\r\n                    event.detail.next.dataset.transitionDuration,\r\n                    event.detail.transitionDuration\r\n                );\r\n                return;\r\n            } else {\r\n                window.console.log( \"impress goto plugin: \" + data.gotoNext +\r\n                                    \" is not a step in this impress presentation.\" );\r\n            }\r\n        }\r\n\r\n        // Handle event.target data-goto-prev attribute\r\n        if ( isNumber( data.gotoPrev ) && event.detail.reason === \"prev\" ) {\r\n            event.detail.next = steps[ data.gotoPrev ];\r\n            event.detail.transitionDuration = lib.util.toNumber(\r\n                event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n            );\r\n            return;\r\n        }\r\n        if ( data.gotoPrev && event.detail.reason === \"prev\" ) {\r\n            var newTarget = document.getElementById( data.gotoPrev ); // jshint ignore:line\r\n            if ( newTarget && newTarget.classList.contains( \"step\" ) ) {\r\n                event.detail.next = newTarget;\r\n                event.detail.transitionDuration = lib.util.toNumber(\r\n                    event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n                );\r\n                return;\r\n            } else {\r\n                window.console.log( \"impress goto plugin: \" + data.gotoPrev +\r\n                                    \" is not a step in this impress presentation.\" );\r\n            }\r\n        }\r\n\r\n        // Data-goto=\"\" ///////////////////////////////////////////////////////////////////////////\r\n\r\n        // Handle event.target data-goto attribute\r\n        if ( isNumber( data.goto ) ) {\r\n            event.detail.next = steps[ data.goto ];\r\n            event.detail.transitionDuration = lib.util.toNumber(\r\n                event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n            );\r\n            return;\r\n        }\r\n        if ( data.goto ) {\r\n            var newTarget = document.getElementById( data.goto ); // jshint ignore:line\r\n            if ( newTarget && newTarget.classList.contains( \"step\" ) ) {\r\n                event.detail.next = newTarget;\r\n                event.detail.transitionDuration = lib.util.toNumber(\r\n                    event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n                );\r\n                return;\r\n            } else {\r\n                window.console.log( \"impress goto plugin: \" + data.goto +\r\n                                    \" is not a step in this impress presentation.\" );\r\n            }\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-stepleave phase\r\n    impress.addPreStepLeavePlugin( goto );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Help popup plugin\r\n *\r\n * Example:\r\n *\r\n *     <!-- Show a help popup at start, or if user presses \"H\" -->\r\n *     <div id=\"impress-help\"></div>\r\n *\r\n * For developers:\r\n *\r\n * Typical use for this plugin, is for plugins that support some keypress, to add a line\r\n * to the help popup produced by this plugin. For example \"P: Presenter console\".\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n/* global window, document */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var rows = [];\r\n    var timeoutHandle;\r\n\r\n    var triggerEvent = function( el, eventName, detail ) {\r\n        var event = document.createEvent( \"CustomEvent\" );\r\n        event.initCustomEvent( eventName, true, true, detail );\r\n        el.dispatchEvent( event );\r\n    };\r\n\r\n    var renderHelpDiv = function() {\r\n        var helpDiv = document.getElementById( \"impress-help\" );\r\n        if ( helpDiv ) {\r\n            var html = [];\r\n            for ( var row in rows ) {\r\n                for ( var arrayItem in row ) {\r\n                    html.push( rows[ row ][ arrayItem ] );\r\n                }\r\n            }\r\n            if ( html ) {\r\n                helpDiv.innerHTML = \"<table>\\n\" + html.join( \"\\n\" ) + \"</table>\\n\";\r\n            }\r\n        }\r\n    };\r\n\r\n    var toggleHelp = function() {\r\n        var helpDiv = document.getElementById( \"impress-help\" );\r\n        if ( !helpDiv ) {\r\n            return;\r\n        }\r\n\r\n        if ( helpDiv.style.display === \"block\" ) {\r\n            helpDiv.style.display = \"none\";\r\n        } else {\r\n            helpDiv.style.display = \"block\";\r\n            window.clearTimeout( timeoutHandle );\r\n        }\r\n    };\r\n\r\n    document.addEventListener( \"keyup\", function( event ) {\r\n\r\n        if ( event.keyCode === 72 || event.keyCode === 191 ) { // \"h\" || \"?\"\r\n            event.preventDefault();\r\n            toggleHelp();\r\n        }\r\n    }, false );\r\n\r\n    // API\r\n    // Other plugins can add help texts, typically if they support an action on a keypress.\r\n    /**\r\n     * Add a help text to the help popup.\r\n     *\r\n     * :param: e.detail.command  Example: \"H\"\r\n     * :param: e.detail.text     Example: \"Show this help.\"\r\n     * :param: e.detail.row      Row index from 0 to 9 where to place this help text. Example: 0\r\n     */\r\n    document.addEventListener( \"impress:help:add\", function( e ) {\r\n\r\n        // The idea is for the sender of the event to supply a unique row index, used for sorting.\r\n        // But just in case two plugins would ever use the same row index, we wrap each row into\r\n        // its own array. If there are more than one entry for the same index, they are shown in\r\n        // first come, first serve ordering.\r\n        var rowIndex = e.detail.row;\r\n        if ( typeof rows[ rowIndex ] !== \"object\" || !rows[ rowIndex ].isArray ) {\r\n            rows[ rowIndex ] = [];\r\n        }\r\n        rows[ e.detail.row ].push( \"<tr><td><strong>\" + e.detail.command + \"</strong></td><td>\" +\r\n                                   e.detail.text + \"</td></tr>\" );\r\n        renderHelpDiv();\r\n    } );\r\n\r\n    document.addEventListener( \"impress:init\", function( e ) {\r\n        renderHelpDiv();\r\n\r\n        // At start, show the help for 7 seconds.\r\n        var helpDiv = document.getElementById( \"impress-help\" );\r\n        if ( helpDiv ) {\r\n            helpDiv.style.display = \"block\";\r\n            timeoutHandle = window.setTimeout( function() {\r\n                var helpDiv = document.getElementById( \"impress-help\" );\r\n                helpDiv.style.display = \"none\";\r\n            }, 7000 );\r\n\r\n            // Regster callback to empty the help div on teardown\r\n            var api = e.detail.api;\r\n            api.lib.gc.pushCallback( function() {\r\n                window.clearTimeout( timeoutHandle );\r\n                helpDiv.style.display = \"\";\r\n                helpDiv.innerHTML = \"\";\r\n                rows = [];\r\n            } );\r\n        }\r\n\r\n        // Use our own API to register the help text for \"h\"\r\n        triggerEvent( document, \"impress:help:add\",\r\n                      { command: \"H\", text: \"Show this help\", row: 0 } );\r\n    } );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Adds a presenter console to impress.js\r\n *\r\n * MIT Licensed, see license.txt.\r\n *\r\n * Copyright 2012, 2013, 2015 impress-console contributors (see README.txt)\r\n *\r\n * version: 1.3-dev\r\n *\r\n */\r\n\r\n// This file contains so much HTML, that we will just respectfully disagree about js\r\n/* jshint quotmark:single */\r\n/* global navigator, top, setInterval, clearInterval, document, window */\r\n\r\n( function( document, window ) {\r\n    'use strict';\r\n\r\n    // TODO: Move this to src/lib/util.js\r\n    var triggerEvent = function( el, eventName, detail ) {\r\n        var event = document.createEvent( 'CustomEvent' );\r\n        event.initCustomEvent( eventName, true, true, detail );\r\n        el.dispatchEvent( event );\r\n    };\r\n\r\n    // Create Language object depending on browsers language setting\r\n    var lang;\r\n    switch ( navigator.language ) {\r\n    case 'de':\r\n        lang = {\r\n            'noNotes': '<div class=\"noNotes\">Keine Notizen hierzu</div>',\r\n            'restart': 'Neustart',\r\n            'clickToOpen': 'Klicken um Sprecherkonsole zu öffnen',\r\n            'prev': 'zurück',\r\n            'next': 'weiter',\r\n            'loading': 'initalisiere',\r\n            'ready': 'Bereit',\r\n            'moving': 'in Bewegung',\r\n            'useAMPM': false\r\n        };\r\n        break;\r\n    case 'en': // jshint ignore:line\r\n    default : // jshint ignore:line\r\n        lang = {\r\n            'noNotes': '<div class=\"noNotes\">No notes for this step</div>',\r\n            'restart': 'Restart',\r\n            'clickToOpen': 'Click to open speaker console',\r\n            'prev': 'Prev',\r\n            'next': 'Next',\r\n            'loading': 'Loading',\r\n            'ready': 'Ready',\r\n            'moving': 'Moving',\r\n            'useAMPM': false\r\n        };\r\n        break;\r\n    }\r\n\r\n    // Settings to set iframe in speaker console\r\n    const preViewDefaultFactor = 0.7;\r\n    const preViewMinimumFactor = 0.5;\r\n    const preViewGap    = 4;\r\n\r\n    // This is the default template for the speaker console window\r\n    const consoleTemplate = '<!DOCTYPE html>' +\r\n        '<html id=\"impressconsole\"><head>' +\r\n\r\n          // Order is important: If user provides a cssFile, those will win, because they're later\r\n          '{{cssStyle}}' +\r\n          '{{cssLink}}' +\r\n        '</head><body>' +\r\n        '<div id=\"console\">' +\r\n          '<div id=\"views\">' +\r\n            '<iframe id=\"slideView\" scrolling=\"no\"></iframe>' +\r\n            '<iframe id=\"preView\" scrolling=\"no\"></iframe>' +\r\n            '<div id=\"blocker\"></div>' +\r\n          '</div>' +\r\n          '<div id=\"notes\"></div>' +\r\n        '</div>' +\r\n        '<div id=\"controls\"> ' +\r\n          '<div id=\"prev\"><a  href=\"#\" onclick=\"impress().prev(); return false;\" />' +\r\n            '{{prev}}</a></div>' +\r\n          '<div id=\"next\"><a  href=\"#\" onclick=\"impress().next(); return false;\" />' +\r\n            '{{next}}</a></div>' +\r\n          '<div id=\"clock\">--:--</div>' +\r\n          '<div id=\"timer\" onclick=\"timerReset()\">00m 00s</div>' +\r\n          '<div id=\"status\">{{loading}}</div>' +\r\n        '</div>' +\r\n        '</body></html>';\r\n\r\n    // Default css location\r\n    var cssFileOldDefault = 'css/impressConsole.css';\r\n    var cssFile = undefined; // jshint ignore:line\r\n\r\n    // Css for styling iframs on the console\r\n    var cssFileIframeOldDefault = 'css/iframe.css';\r\n    var cssFileIframe = undefined; // jshint ignore:line\r\n\r\n    // All console windows, so that you can call impressConsole() repeatedly.\r\n    var allConsoles = {};\r\n\r\n    // Zero padding helper function:\r\n    var zeroPad = function( i ) {\r\n        return ( i < 10 ? '0' : '' ) + i;\r\n    };\r\n\r\n    // The console object\r\n    var impressConsole = window.impressConsole = function( rootId ) {\r\n\r\n        rootId = rootId || 'impress';\r\n\r\n        if ( allConsoles[ rootId ] ) {\r\n            return allConsoles[ rootId ];\r\n        }\r\n\r\n        // Root presentation elements\r\n        var root = document.getElementById( rootId );\r\n\r\n        var consoleWindow = null;\r\n\r\n        var nextStep = function() {\r\n            var classes = '';\r\n            var nextElement = document.querySelector( '.active' );\r\n\r\n            // Return to parents as long as there is no next sibling\r\n            while ( !nextElement.nextElementSibling && nextElement.parentNode ) {\r\n                nextElement = nextElement.parentNode;\r\n            }\r\n            nextElement = nextElement.nextElementSibling;\r\n            while ( nextElement ) {\r\n                classes = nextElement.attributes[ 'class' ];\r\n                if ( classes && classes.value.indexOf( 'step' ) !== -1 ) {\r\n                    consoleWindow.document.getElementById( 'blocker' ).innerHTML = lang.next;\r\n                    return nextElement;\r\n                }\r\n\r\n                if ( nextElement.firstElementChild ) { // First go into deep\r\n                    nextElement = nextElement.firstElementChild;\r\n                } else {\r\n\r\n                    // Go to next sibling or through parents until there is a next sibling\r\n                    while ( !nextElement.nextElementSibling && nextElement.parentNode ) {\r\n                        nextElement = nextElement.parentNode;\r\n                    }\r\n                    nextElement = nextElement.nextElementSibling;\r\n                }\r\n            }\r\n\r\n            // No next element. Pick the first\r\n            consoleWindow.document.getElementById( 'blocker' ).innerHTML = lang.restart;\r\n            return document.querySelector( '.step' );\r\n        };\r\n\r\n        // Sync the notes to the step\r\n        var onStepLeave = function() {\r\n            if ( consoleWindow ) {\r\n\r\n                // Set notes to next steps notes.\r\n                var newNotes = document.querySelector( '.active' ).querySelector( '.notes' );\r\n                if ( newNotes ) {\r\n                    newNotes = newNotes.innerHTML;\r\n                } else {\r\n                    newNotes = lang.noNotes;\r\n                }\r\n                consoleWindow.document.getElementById( 'notes' ).innerHTML = newNotes;\r\n\r\n                // Set the views\r\n                var baseURL = document.URL.substring( 0, document.URL.search( '#/' ) );\r\n                var slideSrc = baseURL + '#' + document.querySelector( '.active' ).id;\r\n                var preSrc = baseURL + '#' + nextStep().id;\r\n                var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n\r\n                // Setting them when they are already set causes glithes in Firefox, so check first:\r\n                if ( slideView.src !== slideSrc ) {\r\n                    slideView.src = slideSrc;\r\n                }\r\n                var preView = consoleWindow.document.getElementById( 'preView' );\r\n                if ( preView.src !== preSrc ) {\r\n                    preView.src = preSrc;\r\n                }\r\n\r\n                consoleWindow.document.getElementById( 'status' ).innerHTML =\r\n                    '<span class=\"moving\">' + lang.moving + '</span>';\r\n            }\r\n        };\r\n\r\n        // Sync the previews to the step\r\n        var onStepEnter = function() {\r\n            if ( consoleWindow ) {\r\n\r\n                // We do everything here again, because if you stopped the previos step to\r\n                // early, the onstepleave trigger is not called for that step, so\r\n                // we need this to sync things.\r\n                var newNotes = document.querySelector( '.active' ).querySelector( '.notes' );\r\n                if ( newNotes ) {\r\n                    newNotes = newNotes.innerHTML;\r\n                } else {\r\n                    newNotes = lang.noNotes;\r\n                }\r\n                var notes = consoleWindow.document.getElementById( 'notes' );\r\n                notes.innerHTML = newNotes;\r\n                notes.scrollTop = 0;\r\n\r\n                // Set the views\r\n                var baseURL = document.URL.substring( 0, document.URL.search( '#/' ) );\r\n                var slideSrc = baseURL + '#' + document.querySelector( '.active' ).id;\r\n                var preSrc = baseURL + '#' + nextStep().id;\r\n                var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n\r\n                // Setting them when they are already set causes glithes in Firefox, so check first:\r\n                if ( slideView.src !== slideSrc ) {\r\n                    slideView.src = slideSrc;\r\n                }\r\n                var preView = consoleWindow.document.getElementById( 'preView' );\r\n                if ( preView.src !== preSrc ) {\r\n                    preView.src = preSrc;\r\n                }\r\n\r\n                consoleWindow.document.getElementById( 'status' ).innerHTML =\r\n                    '<span  class=\"ready\">' + lang.ready + '</span>';\r\n            }\r\n        };\r\n\r\n        // Sync substeps\r\n        var onSubstep = function( event ) {\r\n            if ( consoleWindow ) {\r\n                if ( event.detail.reason === 'next' ) {\r\n                    onSubstepShow();\r\n                }\r\n                if ( event.detail.reason === 'prev' ) {\r\n                    onSubstepHide();\r\n                }\r\n            }\r\n        };\r\n\r\n        var onSubstepShow = function() {\r\n            var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n            triggerEventInView( slideView, 'impress:substep:show' );\r\n        };\r\n\r\n        var onSubstepHide = function() {\r\n            var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n            triggerEventInView( slideView, 'impress:substep:hide' );\r\n        };\r\n\r\n        var triggerEventInView = function( frame, eventName, detail ) {\r\n\r\n            // Note: Unfortunately Chrome does not allow createEvent on file:// URLs, so this won't\r\n            // work. This does work on Firefox, and should work if viewing the presentation on a\r\n            // http:// URL on Chrome.\r\n            var event = frame.contentDocument.createEvent( 'CustomEvent' );\r\n            event.initCustomEvent( eventName, true, true, detail );\r\n            frame.contentDocument.dispatchEvent( event );\r\n        };\r\n\r\n        var spaceHandler = function() {\r\n            var notes = consoleWindow.document.getElementById( 'notes' );\r\n            if ( notes.scrollTopMax - notes.scrollTop > 20 ) {\r\n               notes.scrollTop = notes.scrollTop + notes.clientHeight * 0.8;\r\n            } else {\r\n               window.impress().next();\r\n            }\r\n        };\r\n\r\n        var timerReset = function() {\r\n            consoleWindow.timerStart = new Date();\r\n        };\r\n\r\n        // Show a clock\r\n        var clockTick = function() {\r\n            var now = new Date();\r\n            var hours = now.getHours();\r\n            var minutes = now.getMinutes();\r\n            var seconds = now.getSeconds();\r\n            var ampm = '';\r\n\r\n            if ( lang.useAMPM ) {\r\n                ampm = ( hours < 12 ) ? 'AM' : 'PM';\r\n                hours = ( hours > 12 ) ? hours - 12 : hours;\r\n                hours = ( hours === 0 ) ? 12 : hours;\r\n            }\r\n\r\n            // Clock\r\n            var clockStr = zeroPad( hours ) + ':' + zeroPad( minutes ) + ':' + zeroPad( seconds ) +\r\n                           ' ' + ampm;\r\n            consoleWindow.document.getElementById( 'clock' ).firstChild.nodeValue = clockStr;\r\n\r\n            // Timer\r\n            seconds = Math.floor( ( now - consoleWindow.timerStart ) / 1000 );\r\n            minutes = Math.floor( seconds / 60 );\r\n            seconds = Math.floor( seconds % 60 );\r\n            consoleWindow.document.getElementById( 'timer' ).firstChild.nodeValue =\r\n                zeroPad( minutes ) + 'm ' + zeroPad( seconds ) + 's';\r\n\r\n            if ( !consoleWindow.initialized ) {\r\n\r\n                // Nudge the slide windows after load, or they will scrolled wrong on Firefox.\r\n                consoleWindow.document.getElementById( 'slideView' ).contentWindow.scrollTo( 0, 0 );\r\n                consoleWindow.document.getElementById( 'preView' ).contentWindow.scrollTo( 0, 0 );\r\n                consoleWindow.initialized = true;\r\n            }\r\n        };\r\n\r\n        var registerKeyEvent = function( keyCodes, handler, window ) {\r\n            if ( window === undefined ) {\r\n                window = consoleWindow;\r\n            }\r\n\r\n            // Prevent default keydown action when one of supported key is pressed\r\n            window.document.addEventListener( 'keydown', function( event ) {\r\n                if ( !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey &&\r\n                     keyCodes.indexOf( event.keyCode ) !== -1 ) {\r\n                    event.preventDefault();\r\n                }\r\n            }, false );\r\n\r\n            // Trigger impress action on keyup\r\n            window.document.addEventListener( 'keyup', function( event ) {\r\n                if ( !event.ctrlKey && !event.altKey && !event.shiftKey && !event.metaKey &&\r\n                     keyCodes.indexOf( event.keyCode ) !== -1 ) {\r\n                        handler();\r\n                        event.preventDefault();\r\n                }\r\n            }, false );\r\n        };\r\n\r\n        var consoleOnLoad = function() {\r\n                var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n                var preView = consoleWindow.document.getElementById( 'preView' );\r\n\r\n                // Firefox:\r\n                slideView.contentDocument.body.classList.add( 'impress-console' );\r\n                preView.contentDocument.body.classList.add( 'impress-console' );\r\n                if ( cssFileIframe !== undefined ) {\r\n                    slideView.contentDocument.head.insertAdjacentHTML(\r\n                        'beforeend',\r\n                        '<link rel=\"stylesheet\" type=\"text/css\" href=\"' + cssFileIframe + '\">'\r\n                    );\r\n                    preView.contentDocument.head.insertAdjacentHTML(\r\n                        'beforeend',\r\n                        '<link rel=\"stylesheet\" type=\"text/css\" href=\"' + cssFileIframe + '\">'\r\n                    );\r\n                }\r\n\r\n                // Chrome:\r\n                slideView.addEventListener( 'load', function() {\r\n                        slideView.contentDocument.body.classList.add( 'impress-console' );\r\n                        if ( cssFileIframe !== undefined ) {\r\n                            slideView.contentDocument.head.insertAdjacentHTML(\r\n                                'beforeend',\r\n                                '<link rel=\"stylesheet\" type=\"text/css\" href=\"' +\r\n                                    cssFileIframe + '\">'\r\n                            );\r\n                        }\r\n                } );\r\n                preView.addEventListener( 'load', function() {\r\n                        preView.contentDocument.body.classList.add( 'impress-console' );\r\n                        if ( cssFileIframe !== undefined ) {\r\n                            preView.contentDocument.head.insertAdjacentHTML(\r\n                                'beforeend',\r\n                                '<link rel=\"stylesheet\" type=\"text/css\" href=\"' +\r\n                                    cssFileIframe + '\">' );\r\n                        }\r\n                } );\r\n        };\r\n\r\n        var open = function() {\r\n            if ( top.isconsoleWindow ) {\r\n                return;\r\n            }\r\n\r\n            if ( consoleWindow && !consoleWindow.closed ) {\r\n                consoleWindow.focus();\r\n            } else {\r\n                consoleWindow = window.open( '', 'impressConsole' );\r\n\r\n                // If opening failes this may be because the browser prevents this from\r\n                // not (or less) interactive JavaScript...\r\n                if ( consoleWindow == null ) {\r\n\r\n                    // ... so I add a button to klick.\r\n                    // workaround on firefox\r\n                    var message = document.createElement( 'div' );\r\n                    message.id = 'impress-console-button';\r\n                    message.style.position = 'fixed';\r\n                    message.style.left = 0;\r\n                    message.style.top = 0;\r\n                    message.style.right = 0;\r\n                    message.style.bottom = 0;\r\n                    message.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';\r\n                    var clickStr = 'var x = document.getElementById(\\'impress-console-button\\');' +\r\n                                     'x.parentNode.removeChild(x);' +\r\n                                     'var r = document.getElementById(\\'' + rootId + '\\');' +\r\n                                     'impress(\\'' + rootId +\r\n                                     '\\').lib.util.triggerEvent(r, \\'impress:console:open\\', {})';\r\n                    var styleStr = 'margin: 25vh 25vw;width:50vw;height:50vh;';\r\n                    message.innerHTML = '<button style=\"' + styleStr + '\" ' +\r\n                                                 'onclick=\"' + clickStr + '\">' +\r\n                                        lang.clickToOpen +\r\n                                        '</button>';\r\n                    document.body.appendChild( message );\r\n                    return;\r\n                }\r\n\r\n                var cssLink = '';\r\n                if ( cssFile !== undefined ) {\r\n                    cssLink = '<link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"' +\r\n                              cssFile + '\">';\r\n                }\r\n\r\n                // This sets the window location to the main window location, so css can be loaded:\r\n                consoleWindow.document.open();\r\n\r\n                // Write the template:\r\n                consoleWindow.document.write(\r\n\r\n                    // CssStyleStr is lots of inline <style></style> defined at the end of this file\r\n                    consoleTemplate.replace( '{{cssStyle}}', cssStyleStr() )\r\n                                   .replace( '{{cssLink}}', cssLink )\r\n                                   .replace( /{{.*?}}/gi, function( x ) {\r\n                                       return lang[ x.substring( 2, x.length - 2 ) ]; }\r\n                                   )\r\n                );\r\n                consoleWindow.document.title = 'Speaker Console (' + document.title + ')';\r\n                consoleWindow.impress = window.impress;\r\n\r\n                // We set this flag so we can detect it later, to prevent infinite popups.\r\n                consoleWindow.isconsoleWindow = true;\r\n\r\n                // Set the onload function:\r\n                consoleWindow.onload = consoleOnLoad;\r\n\r\n                // Add clock tick\r\n                consoleWindow.timerStart = new Date();\r\n                consoleWindow.timerReset = timerReset;\r\n                consoleWindow.clockInterval = setInterval( allConsoles[ rootId ].clockTick, 1000 );\r\n\r\n                // Keyboard navigation handlers\r\n                // 33: pg up, 37: left, 38: up\r\n                registerKeyEvent( [ 33, 37, 38 ], window.impress().prev );\r\n\r\n                // 34: pg down, 39: right, 40: down\r\n                registerKeyEvent( [ 34, 39, 40 ], window.impress().next );\r\n\r\n                // 32: space\r\n                registerKeyEvent( [ 32 ], spaceHandler );\r\n\r\n                // 82: R\r\n                registerKeyEvent( [ 82 ], timerReset );\r\n\r\n                // Cleanup\r\n                consoleWindow.onbeforeunload = function() {\r\n\r\n                    // I don't know why onunload doesn't work here.\r\n                    clearInterval( consoleWindow.clockInterval );\r\n                };\r\n\r\n                // It will need a little nudge on Firefox, but only after loading:\r\n                onStepEnter();\r\n                consoleWindow.initialized = false;\r\n                consoleWindow.document.close();\r\n\r\n                //Catch any window resize to pass size on\r\n                window.onresize = resize;\r\n                consoleWindow.onresize = resize;\r\n\r\n                return consoleWindow;\r\n            }\r\n        };\r\n\r\n        var resize = function() {\r\n            var slideView = consoleWindow.document.getElementById( 'slideView' );\r\n            var preView = consoleWindow.document.getElementById( 'preView' );\r\n\r\n            // Get ratio of presentation\r\n            var ratio = window.innerHeight / window.innerWidth;\r\n\r\n            // Get size available for views\r\n            var views = consoleWindow.document.getElementById( 'views' );\r\n\r\n            // SlideView may have a border or some padding:\r\n            // asuming same border width on both direktions\r\n            var delta = slideView.offsetWidth - slideView.clientWidth;\r\n\r\n            // Set views\r\n            var slideViewWidth = ( views.clientWidth - delta );\r\n            var slideViewHeight = Math.floor( slideViewWidth * ratio );\r\n\r\n            var preViewTop = slideViewHeight + preViewGap;\r\n\r\n            var preViewWidth = Math.floor( slideViewWidth * preViewDefaultFactor );\r\n            var preViewHeight = Math.floor( slideViewHeight * preViewDefaultFactor );\r\n\r\n            // Shrink preview to fit into space available\r\n            if ( views.clientHeight - delta < preViewTop + preViewHeight ) {\r\n                preViewHeight = views.clientHeight - delta - preViewTop;\r\n                preViewWidth = Math.floor( preViewHeight / ratio );\r\n            }\r\n\r\n            // If preview is not high enough forget ratios!\r\n            if ( preViewWidth <= Math.floor( slideViewWidth * preViewMinimumFactor ) ) {\r\n                slideViewWidth = ( views.clientWidth - delta );\r\n                slideViewHeight = Math.floor( ( views.clientHeight - delta - preViewGap ) /\r\n                                             ( 1 + preViewMinimumFactor ) );\r\n\r\n                preViewTop = slideViewHeight + preViewGap;\r\n\r\n                preViewWidth = Math.floor( slideViewWidth * preViewMinimumFactor );\r\n                preViewHeight = views.clientHeight - delta - preViewTop;\r\n            }\r\n\r\n            // Set the calculated into styles\r\n            slideView.style.width = slideViewWidth + 'px';\r\n            slideView.style.height = slideViewHeight + 'px';\r\n\r\n            preView.style.top = preViewTop + 'px';\r\n\r\n            preView.style.width = preViewWidth + 'px';\r\n            preView.style.height = preViewHeight + 'px';\r\n        };\r\n\r\n        var _init = function( cssConsole, cssIframe ) {\r\n            if ( cssConsole !== undefined ) {\r\n                cssFile = cssConsole;\r\n            }\r\n\r\n            // You can also specify the css in the presentation root div:\r\n            // <div id=\"impress\" data-console-css=...\" data-console-css-iframe=\"...\">\r\n            else if ( root.dataset.consoleCss !== undefined ) {\r\n                cssFile = root.dataset.consoleCss;\r\n            }\r\n\r\n            if ( cssIframe !== undefined ) {\r\n                cssFileIframe = cssIframe;\r\n            } else if ( root.dataset.consoleCssIframe !== undefined ) {\r\n                cssFileIframe = root.dataset.consoleCssIframe;\r\n            }\r\n\r\n            // Register the event\r\n            root.addEventListener( 'impress:stepleave', onStepLeave );\r\n            root.addEventListener( 'impress:stepenter', onStepEnter );\r\n            root.addEventListener( 'impress:substep:stepleaveaborted', onSubstep );\r\n            root.addEventListener( 'impress:substep:show', onSubstepShow );\r\n            root.addEventListener( 'impress:substep:hide', onSubstepHide );\r\n\r\n            //When the window closes, clean up after ourselves.\r\n            window.onunload = function() {\r\n                if ( consoleWindow && !consoleWindow.closed ) {\r\n                    consoleWindow.close();\r\n                }\r\n            };\r\n\r\n            //Open speaker console when they press 'p'\r\n            registerKeyEvent( [ 80 ], open, window );\r\n\r\n            //Btw, you can also launch console automatically:\r\n            //<div id=\"impress\" data-console-autolaunch=\"true\">\r\n            if ( root.dataset.consoleAutolaunch === 'true' ) {\r\n                open();\r\n            }\r\n        };\r\n\r\n        var init = function( cssConsole, cssIframe ) {\r\n            if ( ( cssConsole === undefined || cssConsole === cssFileOldDefault ) &&\r\n                 ( cssIframe === undefined  || cssIframe === cssFileIframeOldDefault ) ) {\r\n                window.console.log( 'impressConsole().init() is deprecated. ' +\r\n                                   'impressConsole is now initialized automatically when you ' +\r\n                                   'call impress().init().' );\r\n            }\r\n            _init( cssConsole, cssIframe );\r\n        };\r\n\r\n        // New API for impress.js plugins is based on using events\r\n        root.addEventListener( 'impress:console:open', function() {\r\n            open();\r\n        } );\r\n\r\n        /**\r\n         * Register a key code to an event handler\r\n         *\r\n         * :param: event.detail.keyCodes    List of key codes\r\n         * :param: event.detail.handler     A function registered as the event handler\r\n         * :param: event.detail.window      The console window to register the keycode in\r\n         */\r\n        root.addEventListener( 'impress:console:registerKeyEvent', function( event ) {\r\n            registerKeyEvent( event.detail.keyCodes, event.detail.handler, event.detail.window );\r\n        } );\r\n\r\n        // Return the object\r\n        allConsoles[ rootId ] = { init: init, open: open, clockTick: clockTick,\r\n                               registerKeyEvent: registerKeyEvent, _init: _init };\r\n        return allConsoles[ rootId ];\r\n\r\n    };\r\n\r\n    // This initializes impressConsole automatically when initializing impress itself\r\n    document.addEventListener( 'impress:init', function( event ) {\r\n\r\n        // Note: impressConsole wants the id string, not the DOM element directly\r\n        impressConsole( event.target.id )._init();\r\n\r\n        // Add 'P' to the help popup\r\n        triggerEvent( document, 'impress:help:add',\r\n                        { command: 'P', text: 'Presenter console', row: 10 } );\r\n    } );\r\n\r\n    // Returns a string to be used inline as a css <style> element in the console window.\r\n    // Apologies for length, but hiding it here at the end to keep it away from rest of the code.\r\n    var cssStyleStr = function() {\r\n        return `<style>\r\n            #impressconsole body {\r\n                background-color: rgb(255, 255, 255);\r\n                padding: 0;\r\n                margin: 0;\r\n                font-family: verdana, arial, sans-serif;\r\n                font-size: 2vw;\r\n            }\r\n\r\n            #impressconsole div#console {\r\n                position: absolute;\r\n                top: 0.5vw;\r\n                left: 0.5vw;\r\n                right: 0.5vw;\r\n                bottom: 3vw;\r\n                margin: 0;\r\n            }\r\n\r\n            #impressconsole div#views, #impressconsole div#notes {\r\n                position: absolute;\r\n                top: 0;\r\n                bottom: 0;\r\n            }\r\n\r\n            #impressconsole div#views {\r\n                left: 0;\r\n                right: 50vw;\r\n                overflow: hidden;\r\n            }\r\n\r\n            #impressconsole div#blocker {\r\n                position: absolute;\r\n                right: 0;\r\n                bottom: 0;\r\n            }\r\n\r\n            #impressconsole div#notes {\r\n                left: 50vw;\r\n                right: 0;\r\n                overflow-x: hidden;\r\n                overflow-y: auto;\r\n                padding: 0.3ex;\r\n                background-color: rgb(255, 255, 255);\r\n                border: solid 1px rgb(120, 120, 120);\r\n            }\r\n\r\n            #impressconsole div#notes .noNotes {\r\n                color: rgb(200, 200, 200);\r\n            }\r\n\r\n            #impressconsole div#notes p {\r\n                margin-top: 0;\r\n            }\r\n\r\n            #impressconsole iframe {\r\n                position: absolute;\r\n                margin: 0;\r\n                padding: 0;\r\n                left: 0;\r\n                border: solid 1px rgb(120, 120, 120);\r\n            }\r\n\r\n            #impressconsole iframe#slideView {\r\n                top: 0;\r\n                width: 49vw;\r\n                height: 49vh;\r\n            }\r\n\r\n            #impressconsole iframe#preView {\r\n                opacity: 0.7;\r\n                top: 50vh;\r\n                width: 30vw;\r\n                height: 30vh;\r\n            }\r\n\r\n            #impressconsole div#controls {\r\n                margin: 0;\r\n                position: absolute;\r\n                bottom: 0.25vw;\r\n                left: 0.5vw;\r\n                right: 0.5vw;\r\n                height: 2.5vw;\r\n                background-color: rgb(255, 255, 255);\r\n                background-color: rgba(255, 255, 255, 0.6);\r\n            }\r\n\r\n            #impressconsole div#prev, div#next {\r\n            }\r\n\r\n            #impressconsole div#prev a, #impressconsole div#next a {\r\n                display: block;\r\n                border: solid 1px rgb(70, 70, 70);\r\n                border-radius: 0.5vw;\r\n                font-size: 1.5vw;\r\n                padding: 0.25vw;\r\n                text-decoration: none;\r\n                background-color: rgb(220, 220, 220);\r\n                color: rgb(0, 0, 0);\r\n            }\r\n\r\n            #impressconsole div#prev a:hover, #impressconsole div#next a:hover {\r\n                background-color: rgb(245, 245, 245);\r\n            }\r\n\r\n            #impressconsole div#prev {\r\n                float: left;\r\n            }\r\n\r\n            #impressconsole div#next {\r\n                float: right;\r\n            }\r\n\r\n            #impressconsole div#status {\r\n                margin-left: 2em;\r\n                margin-right: 2em;\r\n                text-align: center;\r\n                float: right;\r\n            }\r\n\r\n            #impressconsole div#clock {\r\n                margin-left: 2em;\r\n                margin-right: 2em;\r\n                text-align: center;\r\n                float: left;\r\n            }\r\n\r\n            #impressconsole div#timer {\r\n                margin-left: 2em;\r\n                margin-right: 2em;\r\n                text-align: center;\r\n                float: left;\r\n            }\r\n\r\n            #impressconsole span.moving {\r\n                color: rgb(255, 0, 0);\r\n            }\r\n\r\n            #impressconsole span.ready {\r\n                color: rgb(0, 128, 0);\r\n            }\r\n        </style>`;\r\n    };\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Media Plugin\r\n *\r\n * This plugin will do the following things:\r\n *\r\n *  - Add a special class when playing (body.impress-media-video-playing\r\n *    and body.impress-media-video-playing) and pausing media (body.impress-media-video-paused\r\n *    and body.impress-media-audio-paused) (removing them when ending).\r\n *    This can be useful for example for darkening the background or fading out other elements\r\n *    while a video is playing.\r\n *    Only media at the current step are taken into account. All classes are removed when leaving\r\n *    a step.\r\n *\r\n *  - Introduce the following new data attributes:\r\n *\r\n *    - data-media-autoplay=\"true\": Autostart media when entering its step.\r\n *    - data-media-autostop=\"true\": Stop media (= pause and reset to start), when leaving its\r\n *      step.\r\n *    - data-media-autopause=\"true\": Pause media but keep current time when leaving its step.\r\n *\r\n *    When these attributes are added to a step they are inherited by all media on this step.\r\n *    Of course this setting can be overwritten by adding different attributes to inidvidual\r\n *    media.\r\n *\r\n *    The same rule applies when this attributes is added to the root element. Settings can be\r\n *    overwritten for individual steps and media.\r\n *\r\n *    Examples:\r\n *    - data-media-autostart=\"true\" data-media-autostop=\"true\": start media on enter, stop on\r\n *      leave, restart from beginning when re-entering the step.\r\n *\r\n *    - data-media-autostart=\"true\" data-media-autopause=\"true\": start media on enter, pause on\r\n *      leave, resume on re-enter\r\n *\r\n *    - data-media-autostart=\"true\" data-media-autostop=\"true\" data-media-autopause=\"true\": start\r\n *      media on enter, stop on leave (stop overwrites pause).\r\n *\r\n *    - data-media-autostart=\"true\" data-media-autopause=\"false\": let media start automatically\r\n *      when entering a step and let it play when leaving the step.\r\n *\r\n *    - <div id=\"impress\" data-media-autostart=\"true\"> ... <div class=\"step\"\r\n *      data-media-autostart=\"false\">\r\n *      All media is startet automatically on all steps except the one that has the\r\n *      data-media-autostart=\"false\" attribute.\r\n *\r\n *  - Pro tip: Use <audio onended=\"impress().next()\"> or <video onended=\"impress().next()\"> to\r\n *    proceed to the next step automatically, when the end of the media is reached.\r\n *\r\n *\r\n * Copyright 2018 Holger Teichert (@complanar)\r\n * Released under the MIT license.\r\n */\r\n/* global window, document */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var root, api, gc, attributeTracker;\r\n\r\n    attributeTracker = [];\r\n\r\n    // Function names\r\n    var enhanceMediaNodes,\r\n        enhanceMedia,\r\n        removeMediaClasses,\r\n        onStepenterDetectImpressConsole,\r\n        onStepenter,\r\n        onStepleave,\r\n        onPlay,\r\n        onPause,\r\n        onEnded,\r\n        getMediaAttribute,\r\n        teardown;\r\n\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        root = event.target;\r\n        api = event.detail.api;\r\n        gc = api.lib.gc;\r\n\r\n        enhanceMedia();\r\n\r\n        gc.pushCallback( teardown );\r\n    }, false );\r\n\r\n    teardown = function() {\r\n        var el, i;\r\n        removeMediaClasses();\r\n        for ( i = 0; i < attributeTracker.length; i += 1 ) {\r\n            el = attributeTracker[ i ];\r\n            el.node.removeAttribute( el.attr );\r\n        }\r\n        attributeTracker = [];\r\n    };\r\n\r\n    getMediaAttribute = function( attributeName, nodes ) {\r\n        var attrName, attrValue, i, node;\r\n        attrName = \"data-media-\" + attributeName;\r\n\r\n        // Look for attributes in all nodes\r\n        for ( i = 0; i < nodes.length; i += 1 ) {\r\n            node = nodes[ i ];\r\n\r\n            // First test, if the attribute exists, because some browsers may return\r\n            // an empty string for non-existing attributes - specs are not clear at that point\r\n            if ( node.hasAttribute( attrName ) ) {\r\n\r\n                // Attribute found, return their parsed boolean value, empty strings count as true\r\n                // to enable empty value booleans (common in html5 but not allowed in well formed\r\n                // xml).\r\n                attrValue = node.getAttribute( attrName );\r\n                if ( attrValue === \"\" || attrValue === \"true\" ) {\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // No attribute found at current node, proceed with next round\r\n        }\r\n\r\n        // Last resort: no attribute found - return undefined to distiguish from false\r\n        return undefined;\r\n    };\r\n\r\n    onPlay = function( event ) {\r\n        var type = event.target.nodeName.toLowerCase();\r\n        document.body.classList.add( \"impress-media-\" + type + \"-playing\" );\r\n        document.body.classList.remove( \"impress-media-\" + type + \"-paused\" );\r\n    };\r\n\r\n    onPause = function( event ) {\r\n        var type = event.target.nodeName.toLowerCase();\r\n        document.body.classList.add( \"impress-media-\" + type + \"-paused\" );\r\n        document.body.classList.remove( \"impress-media-\" + type + \"-playing\" );\r\n    };\r\n\r\n    onEnded = function( event ) {\r\n        var type = event.target.nodeName.toLowerCase();\r\n        document.body.classList.remove( \"impress-media-\" + type + \"-playing\" );\r\n        document.body.classList.remove( \"impress-media-\" + type + \"-paused\" );\r\n    };\r\n\r\n    removeMediaClasses = function() {\r\n        var type, types;\r\n        types = [ \"video\", \"audio\" ];\r\n        for ( type in types ) {\r\n            document.body.classList.remove( \"impress-media-\" + types[ type ] + \"-playing\" );\r\n            document.body.classList.remove( \"impress-media-\" + types[ type ] + \"-paused\" );\r\n        }\r\n    };\r\n\r\n    enhanceMediaNodes = function() {\r\n        var i, id, media, mediaElement, type;\r\n\r\n        media = root.querySelectorAll( \"audio, video\" );\r\n        for ( i = 0; i < media.length; i += 1 ) {\r\n            type = media[ i ].nodeName.toLowerCase();\r\n\r\n            // Set an id to identify each media node - used e.g. for cross references by\r\n            // the consoleMedia plugin\r\n            mediaElement = media[ i ];\r\n            id = mediaElement.getAttribute( \"id\" );\r\n            if ( id === undefined || id === null ) {\r\n                mediaElement.setAttribute( \"id\", \"media-\" + type + \"-\" + i );\r\n                attributeTracker.push( { \"node\": mediaElement, \"attr\": \"id\" } );\r\n            }\r\n            gc.addEventListener( mediaElement, \"play\", onPlay );\r\n            gc.addEventListener( mediaElement, \"playing\", onPlay );\r\n            gc.addEventListener( mediaElement, \"pause\", onPause );\r\n            gc.addEventListener( mediaElement, \"ended\", onEnded );\r\n        }\r\n    };\r\n\r\n    enhanceMedia = function() {\r\n        var steps, stepElement, i;\r\n        enhanceMediaNodes();\r\n        steps = document.getElementsByClassName( \"step\" );\r\n        for ( i = 0; i < steps.length; i += 1 ) {\r\n            stepElement = steps[ i ];\r\n\r\n            gc.addEventListener( stepElement, \"impress:stepenter\", onStepenter );\r\n            gc.addEventListener( stepElement, \"impress:stepleave\", onStepleave );\r\n        }\r\n    };\r\n\r\n    onStepenterDetectImpressConsole = function() {\r\n        return {\r\n            \"preview\": ( window.frameElement !== null && window.frameElement.id === \"preView\" ),\r\n            \"slideView\": ( window.frameElement !== null && window.frameElement.id === \"slideView\" )\r\n        };\r\n    };\r\n\r\n    onStepenter = function( event ) {\r\n        var stepElement, media, mediaElement, i, onConsole, autoplay;\r\n        if ( ( !event ) || ( !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        stepElement = event.target;\r\n        removeMediaClasses();\r\n\r\n        media = stepElement.querySelectorAll( \"audio, video\" );\r\n        for ( i = 0; i < media.length; i += 1 ) {\r\n            mediaElement = media[ i ];\r\n\r\n            // Autoplay when (maybe inherited) autoplay setting is true,\r\n            // but only if not on preview of the next step in impressConsole\r\n            onConsole = onStepenterDetectImpressConsole();\r\n            autoplay = getMediaAttribute( \"autoplay\", [ mediaElement, stepElement, root ] );\r\n            if ( autoplay && !onConsole.preview ) {\r\n                if ( onConsole.slideView ) {\r\n                    mediaElement.muted = true;\r\n                }\r\n                mediaElement.play();\r\n            }\r\n        }\r\n    };\r\n\r\n    onStepleave = function( event ) {\r\n        var stepElement, media, i, mediaElement, autoplay, autopause, autostop;\r\n        if ( ( !event || !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        stepElement = event.target;\r\n        media = event.target.querySelectorAll( \"audio, video\" );\r\n        for ( i = 0; i < media.length; i += 1 ) {\r\n            mediaElement = media[ i ];\r\n\r\n            autoplay = getMediaAttribute( \"autoplay\", [ mediaElement, stepElement, root ] );\r\n            autopause = getMediaAttribute( \"autopause\", [ mediaElement, stepElement, root ] );\r\n            autostop = getMediaAttribute( \"autostop\",  [ mediaElement, stepElement, root ] );\r\n\r\n            // If both autostop and autopause are undefined, set it to the value of autoplay\r\n            if ( autostop === undefined && autopause === undefined ) {\r\n                autostop = autoplay;\r\n            }\r\n\r\n            if ( autopause || autostop ) {\r\n                mediaElement.pause();\r\n                if ( autostop ) {\r\n                    mediaElement.currentTime = 0;\r\n                }\r\n            }\r\n        }\r\n        removeMediaClasses();\r\n    };\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Mobile devices support\r\n *\r\n * Allow presentation creators to hide all but 3 slides, to save resources, particularly on mobile\r\n * devices, using classes body.impress-mobile, .step.prev, .step.active and .step.next.\r\n *\r\n * Note: This plugin does not take into account possible redirections done with skip, goto etc\r\n * plugins. Basically it wouldn't work as intended in such cases, but the active step will at least\r\n * be correct.\r\n *\r\n * Adapted to a plugin from a submission by @Kzeni:\r\n * https://github.com/impress/impress.js/issues/333\r\n */\r\n/* global document, navigator */\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    var getNextStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i + 1 < steps.length ) {\r\n                    return steps[ i + 1 ];\r\n                } else {\r\n                    return steps[ 0 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var getPrevStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = steps.length - 1; i >= 0; i-- ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i - 1 >= 0 ) {\r\n                    return steps[ i - 1 ];\r\n                } else {\r\n                    return steps[ steps.length - 1 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // Detect mobile browsers & add CSS class as appropriate.\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var body = document.body;\r\n        if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n                 navigator.userAgent\r\n             ) ) {\r\n            body.classList.add( \"impress-mobile\" );\r\n        }\r\n\r\n        // Unset all this on teardown\r\n        var api = event.detail.api;\r\n        api.lib.gc.pushCallback( function() {\r\n            document.body.classList.remove( \"impress-mobile\" );\r\n            var prev = document.getElementsByClassName( \"prev\" )[ 0 ];\r\n            var next = document.getElementsByClassName( \"next\" )[ 0 ];\r\n            if ( typeof prev !== \"undefined\" ) {\r\n                prev.classList.remove( \"prev\" );\r\n            }\r\n            if ( typeof next !== \"undefined\" ) {\r\n                next.classList.remove( \"next\" );\r\n            }\r\n        } );\r\n    } );\r\n\r\n    // Add prev and next classes to the siblings of the newly entered active step element\r\n    // Remove prev and next classes from their current step elements\r\n    // Note: As an exception we break namespacing rules, as these are useful general purpose\r\n    // classes. (Naming rules would require us to use css classes mobile-next and mobile-prev,\r\n    // based on plugin name.)\r\n    document.addEventListener( \"impress:stepenter\", function( event ) {\r\n\t      var oldprev = document.getElementsByClassName( \"prev\" )[ 0 ];\r\n\t      var oldnext = document.getElementsByClassName( \"next\" )[ 0 ];\r\n\r\n\t      var prev = getPrevStep( event.target );\r\n\t      prev.classList.add( \"prev\" );\r\n\t      var next = getNextStep( event.target );\r\n\t      next.classList.add( \"next\" );\r\n\r\n\t      if ( typeof oldprev !== \"undefined\" ) {\r\n\t\t      oldprev.classList.remove( \"prev\" );\r\n              }\r\n\t      if ( typeof oldnext !== \"undefined\" ) {\r\n\t\t      oldnext.classList.remove( \"next\" );\r\n              }\r\n    } );\r\n} )( document );\r\n\r\n\r\n/**\r\n * Mouse timeout plugin\r\n *\r\n * After 3 seconds of mouse inactivity, add the css class\r\n * `body.impress-mouse-timeout`. On `mousemove`, `click` or `touch`, remove the\r\n * class.\r\n *\r\n * The use case for this plugin is to use CSS to hide elements from the screen\r\n * and only make them visible when the mouse is moved. Examples where this\r\n * might be used are: the toolbar from the toolbar plugin, and the mouse cursor\r\n * itself.\r\n *\r\n * Example CSS:\r\n *\r\n *     body.impress-mouse-timeout {\r\n *         cursor: none;\r\n *     }\r\n *     body.impress-mouse-timeout div#impress-toolbar {\r\n *         display: none;\r\n *     }\r\n *\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n/* global window, document */\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var timeout = 3;\r\n    var timeoutHandle;\r\n\r\n    var hide = function() {\r\n\r\n        // Mouse is now inactive\r\n        document.body.classList.add( \"impress-mouse-timeout\" );\r\n    };\r\n\r\n    var show = function() {\r\n        if ( timeoutHandle ) {\r\n            window.clearTimeout( timeoutHandle );\r\n        }\r\n\r\n        // Mouse is now active\r\n        document.body.classList.remove( \"impress-mouse-timeout\" );\r\n\r\n        // Then set new timeout after which it is considered inactive again\r\n        timeoutHandle = window.setTimeout( hide, timeout * 1000 );\r\n    };\r\n\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var api = event.detail.api;\r\n        var gc = api.lib.gc;\r\n        gc.addEventListener( document, \"mousemove\", show );\r\n        gc.addEventListener( document, \"click\", show );\r\n        gc.addEventListener( document, \"touch\", show );\r\n\r\n        // Set first timeout\r\n        show();\r\n\r\n        // Unset all this on teardown\r\n        gc.pushCallback( function() {\r\n            window.clearTimeout( timeoutHandle );\r\n            document.body.classList.remove( \"impress-mouse-timeout\" );\r\n        } );\r\n    }, false );\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Navigation events plugin\r\n *\r\n * As you can see this part is separate from the impress.js core code.\r\n * It's because these navigation actions only need what impress.js provides with\r\n * its simple API.\r\n *\r\n * This plugin is what we call an _init plugin_. It's a simple kind of\r\n * impress.js plugin. When loaded, it starts listening to the `impress:init`\r\n * event. That event listener initializes the plugin functionality - in this\r\n * case we listen to some keypress and mouse events. The only dependencies on\r\n * core impress.js functionality is the `impress:init` method, as well as using\r\n * the public api `next(), prev(),` etc when keys are pressed.\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Released under the MIT license.\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka\r\n *  version: 0.5.3\r\n *  url:     http://bartaz.github.com/impress.js/\r\n *  source:  http://github.com/bartaz/impress.js/\r\n *\r\n */\r\n/* global document */\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n\r\n        // Getting API from event data.\r\n        // So you don't event need to know what is the id of the root element\r\n        // or anything. `impress:init` event data gives you everything you\r\n        // need to control the presentation that was just initialized.\r\n        var api = event.detail.api;\r\n        var gc = api.lib.gc;\r\n        var util = api.lib.util;\r\n\r\n        // Supported keys are:\r\n        // [space] - quite common in presentation software to move forward\r\n        // [up] [right] / [down] [left] - again common and natural addition,\r\n        // [pgdown] / [pgup] - often triggered by remote controllers,\r\n        // [tab] - this one is quite controversial, but the reason it ended up on\r\n        //   this list is quite an interesting story... Remember that strange part\r\n        //   in the impress.js code where window is scrolled to 0,0 on every presentation\r\n        //   step, because sometimes browser scrolls viewport because of the focused element?\r\n        //   Well, the [tab] key by default navigates around focusable elements, so clicking\r\n        //   it very often caused scrolling to focused element and breaking impress.js\r\n        //   positioning. I didn't want to just prevent this default action, so I used [tab]\r\n        //   as another way to moving to next step... And yes, I know that for the sake of\r\n        //   consistency I should add [shift+tab] as opposite action...\r\n        var isNavigationEvent = function( event ) {\r\n\r\n            // Don't trigger navigation for example when user returns to browser window with ALT+TAB\r\n            if ( event.altKey || event.ctrlKey || event.metaKey ) {\r\n                return false;\r\n            }\r\n\r\n            // In the case of TAB, we force step navigation always, overriding the browser\r\n            // navigation between input elements, buttons and links.\r\n            if ( event.keyCode === 9 ) {\r\n                return true;\r\n            }\r\n\r\n            // With the sole exception of TAB, we also ignore keys pressed if shift is down.\r\n            if ( event.shiftKey ) {\r\n                return false;\r\n            }\r\n\r\n            if ( ( event.keyCode >= 32 && event.keyCode <= 34 ) ||\r\n                 ( event.keyCode >= 37 && event.keyCode <= 40 ) ) {\r\n                return true;\r\n            }\r\n        };\r\n\r\n        // KEYBOARD NAVIGATION HANDLERS\r\n\r\n        // Prevent default keydown action when one of supported key is pressed.\r\n        gc.addEventListener( document, \"keydown\", function( event ) {\r\n            if ( isNavigationEvent( event ) ) {\r\n                event.preventDefault();\r\n            }\r\n        }, false );\r\n\r\n        // Trigger impress action (next or prev) on keyup.\r\n        gc.addEventListener( document, \"keyup\", function( event ) {\r\n            if ( isNavigationEvent( event ) ) {\r\n                if ( event.shiftKey ) {\r\n                    switch ( event.keyCode ) {\r\n                        case 9: // Shift+tab\r\n                            api.prev();\r\n                            break;\r\n                    }\r\n                } else {\r\n                    switch ( event.keyCode ) {\r\n                        case 33: // Pg up\r\n                        case 37: // Left\r\n                        case 38: // Up\r\n                                 api.prev( event );\r\n                                 break;\r\n                        case 9:  // Tab\r\n                        case 32: // Space\r\n                        case 34: // Pg down\r\n                        case 39: // Right\r\n                        case 40: // Down\r\n                                 api.next( event );\r\n                                 break;\r\n                    }\r\n                }\r\n                event.preventDefault();\r\n            }\r\n        }, false );\r\n\r\n        // Delegated handler for clicking on the links to presentation steps\r\n        gc.addEventListener( document, \"click\", function( event ) {\r\n\r\n            // Event delegation with \"bubbling\"\r\n            // check if event target (or any of its parents is a link)\r\n            var target = event.target;\r\n            try {\r\n                while ( ( target.tagName !== \"A\" ) &&\r\n                        ( target !== document.documentElement ) ) {\r\n                    target = target.parentNode;\r\n                }\r\n\r\n                if ( target.tagName === \"A\" ) {\r\n                    var href = target.getAttribute( \"href\" );\r\n\r\n                    // If it's a link to presentation step, target this step\r\n                    if ( href && href[ 0 ] === \"#\" ) {\r\n                        target = document.getElementById( href.slice( 1 ) );\r\n                    }\r\n                }\r\n\r\n                if ( api.goto( target ) ) {\r\n                    event.stopImmediatePropagation();\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n            catch ( err ) {\r\n\r\n                // For example, when clicking on the button to launch speaker console, the button\r\n                // is immediately deleted from the DOM. In this case target is a DOM element when\r\n                // we get it, but turns out to be null if you try to actually do anything with it.\r\n                if ( err instanceof TypeError &&\r\n                     err.message === \"target is null\" ) {\r\n                    return;\r\n                }\r\n                throw err;\r\n            }\r\n        }, false );\r\n\r\n        // Delegated handler for clicking on step elements\r\n        gc.addEventListener( document, \"click\", function( event ) {\r\n            var target = event.target;\r\n            try {\r\n\r\n                // Find closest step element that is not active\r\n                while ( !( target.classList.contains( \"step\" ) &&\r\n                        !target.classList.contains( \"active\" ) ) &&\r\n                        ( target !== document.documentElement ) ) {\r\n                    target = target.parentNode;\r\n                }\r\n                //---COMMENTED TO TURN OFF FUNCTIONALITY---\r\n                // if ( api.goto( target ) ) {\r\n                //     event.preventDefault();\r\n                // }\r\n            }\r\n            catch ( err ) {\r\n\r\n                // For example, when clicking on the button to launch speaker console, the button\r\n                // is immediately deleted from the DOM. In this case target is a DOM element when\r\n                // we get it, but turns out to be null if you try to actually do anything with it.\r\n                if ( err instanceof TypeError &&\r\n                     err.message === \"target is null\" ) {\r\n                    return;\r\n                }\r\n                throw err;\r\n            }\r\n        }, false );\r\n\r\n        // Add a line to the help popup\r\n        util.triggerEvent( document, \"impress:help:add\", { command: \"Left &amp; Right\",\r\n                                                           text: \"Previous &amp; Next step\",\r\n                                                           row: 1 } );\r\n\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\r\n/**\r\n * Navigation UI plugin\r\n *\r\n * This plugin provides UI elements \"back\", \"forward\" and a list to select\r\n * a specific slide number.\r\n *\r\n * The navigation controls are added to the toolbar plugin via DOM events. User must enable the\r\n * toolbar in a presentation to have them visible.\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n\r\n// This file contains so much HTML, that we will just respectfully disagree about js\r\n/* jshint quotmark:single */\r\n/* global document */\r\n\r\n( function( document ) {\r\n    'use strict';\r\n    var toolbar;\r\n    var api;\r\n    var root;\r\n    var steps;\r\n    var hideSteps = [];\r\n    var prev;\r\n    var select;\r\n    var next;\r\n\r\n    var triggerEvent = function( el, eventName, detail ) {\r\n        var event = document.createEvent( 'CustomEvent' );\r\n        event.initCustomEvent( eventName, true, true, detail );\r\n        el.dispatchEvent( event );\r\n    };\r\n\r\n    var makeDomElement = function( html ) {\r\n        var tempDiv = document.createElement( 'div' );\r\n        tempDiv.innerHTML = html;\r\n        return tempDiv.firstChild;\r\n    };\r\n\r\n    var selectOptionsHtml = function() {\r\n        var options = '';\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n\r\n            // Omit steps that are listed as hidden from select widget\r\n            if ( hideSteps.indexOf( steps[ i ] ) < 0 ) {\r\n                options = options + '<option value=\"' + steps[ i ].id + '\">' + // jshint ignore:line\r\n                                    steps[ i ].id + '</option>' + '\\n'; // jshint ignore:line\r\n            }\r\n        }\r\n        return options;\r\n    };\r\n\r\n    var addNavigationControls = function( event ) {\r\n        api = event.detail.api;\r\n        var gc = api.lib.gc;\r\n        root = event.target;\r\n        steps = root.querySelectorAll( '.step' );\r\n\r\n        var prevHtml   = '<button id=\"impress-navigation-ui-prev\" title=\"Previous\" ' +\r\n                         'class=\"impress-navigation-ui\">&lt;</button>';\r\n        var selectHtml = '<select id=\"impress-navigation-ui-select\" title=\"Go to\" ' +\r\n                         'class=\"impress-navigation-ui\">' + '\\n' +\r\n                           selectOptionsHtml() +\r\n                           '</select>';\r\n        var nextHtml   = '<button id=\"impress-navigation-ui-next\" title=\"Next\" ' +\r\n                         'class=\"impress-navigation-ui\">&gt;</button>';\r\n\r\n        prev = makeDomElement( prevHtml );\r\n        prev.addEventListener( 'click',\r\n            function() {\r\n                api.prev();\r\n        } );\r\n        select = makeDomElement( selectHtml );\r\n        select.addEventListener( 'change',\r\n            function( event ) {\r\n                api.goto( event.target.value );\r\n        } );\r\n        gc.addEventListener( root, 'impress:steprefresh', function( event ) {\r\n\r\n            // As impress.js core now allows to dynamically edit the steps, including adding,\r\n            // removing, and reordering steps, we need to requery and redraw the select list on\r\n            // every stepenter event.\r\n            steps = root.querySelectorAll( '.step' );\r\n            select.innerHTML = '\\n' + selectOptionsHtml();\r\n\r\n            // Make sure the list always shows the step we're actually on, even if it wasn't\r\n            // selected from the list\r\n            select.value = event.target.id;\r\n        } );\r\n        next = makeDomElement( nextHtml );\r\n        next.addEventListener( 'click',\r\n            function() {\r\n                api.next();\r\n        } );\r\n\r\n        triggerEvent( toolbar, 'impress:toolbar:appendChild', { group: 0, element: prev } );\r\n        triggerEvent( toolbar, 'impress:toolbar:appendChild', { group: 0, element: select } );\r\n        triggerEvent( toolbar, 'impress:toolbar:appendChild', { group: 0, element: next } );\r\n\r\n    };\r\n\r\n    // API for not listing given step in the select widget.\r\n    // For example, if you set class=\"skip\" on some element, you may not want it to show up in the\r\n    // list either. Otoh we cannot assume that, or anything else, so steps that user wants omitted\r\n    // must be specifically added with this API call.\r\n    document.addEventListener( 'impress:navigation-ui:hideStep', function( event ) {\r\n        hideSteps.push( event.target );\r\n        if ( select ) {\r\n            select.innerHTML = selectOptionsHtml();\r\n        }\r\n    }, false );\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( 'impress:init', function( event ) {\r\n        toolbar = document.querySelector( '#impress-toolbar' );\r\n        if ( toolbar ) {\r\n            addNavigationControls( event );\r\n        }\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\r\n/* global document */\r\n( function( document ) {\r\n    \"use strict\";\r\n    var root;\r\n    var stepids = [];\r\n\r\n    // Get stepids from the steps under impress root\r\n    var getSteps = function() {\r\n        stepids = [];\r\n        var steps = root.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ )\r\n        {\r\n          stepids[ i + 1 ] = steps[ i ].id;\r\n        }\r\n        };\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n            root = event.target;\r\n        getSteps();\r\n        var gc = event.detail.api.lib.gc;\r\n        gc.pushCallback( function() {\r\n            stepids = [];\r\n            if ( progressbar ) {\r\n                progressbar.style.width = \"\";\r\n                        }\r\n            if ( progress ) {\r\n                progress.innerHTML = \"\";\r\n                        }\r\n        } );\r\n    } );\r\n\r\n    var progressbar = document.querySelector( \"div.impress-progressbar div\" );\r\n    var progress = document.querySelector( \"div.impress-progress\" );\r\n\r\n    if ( null !== progressbar || null !== progress ) {\r\n        document.addEventListener( \"impress:stepleave\", function( event ) {\r\n            updateProgressbar( event.detail.next.id );\r\n        } );\r\n\r\n        document.addEventListener( \"impress:steprefresh\", function( event ) {\r\n            getSteps();\r\n            updateProgressbar( event.target.id );\r\n        } );\r\n\r\n    }\r\n\r\n    function updateProgressbar( slideId ) {\r\n        var slideNumber = stepids.indexOf( slideId );\r\n        if ( null !== progressbar ) {\r\n                        var width = 100 / ( stepids.length - 1 ) * ( slideNumber );\r\n            progressbar.style.width = width.toFixed( 2 ) + \"%\";\r\n        }\r\n        if ( null !== progress ) {\r\n            progress.innerHTML = slideNumber + \"/\" + ( stepids.length - 1 );\r\n        }\r\n    }\r\n} )( document );\r\n\r\n/**\r\n * Relative Positioning Plugin\r\n *\r\n * This plugin provides support for defining the coordinates of a step relative\r\n * to the previous step. This is often more convenient when creating presentations,\r\n * since as you add, remove or move steps, you may not need to edit the positions\r\n * as much as is the case with the absolute coordinates supported by impress.js\r\n * core.\r\n *\r\n * Example:\r\n *\r\n *         <!-- Position step 1000 px to the right and 500 px up from the previous step. -->\r\n *         <div class=\"step\" data-rel-x=\"1000\" data-rel-y=\"500\">\r\n *\r\n * Following html attributes are supported for step elements:\r\n *\r\n *     data-rel-x\r\n *     data-rel-y\r\n *     data-rel-z\r\n *\r\n * These values are also inherited from the previous step. This makes it easy to\r\n * create a boring presentation where each slide shifts for example 1000px down\r\n * from the previous.\r\n *\r\n * In addition to plain numbers, which are pixel values, it is also possible to\r\n * define relative positions as a multiple of screen height and width, using\r\n * a unit of \"h\" and \"w\", respectively, appended to the number.\r\n *\r\n * Example:\r\n *\r\n *        <div class=\"step\" data-rel-x=\"1.5w\" data-rel-y=\"1.5h\">\r\n *\r\n * This plugin is a *pre-init plugin*. It is called synchronously from impress.js\r\n * core at the beginning of `impress().init()`. This allows it to process its own\r\n * data attributes first, and possibly alter the data-x, data-y and data-z attributes\r\n * that will then be processed by `impress().init()`.\r\n *\r\n * (Another name for this kind of plugin might be called a *filter plugin*, but\r\n * *pre-init plugin* is more generic, as a plugin might do whatever it wants in\r\n * the pre-init stage.)\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n\r\n/* global document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    var startingState = {};\r\n\r\n    /**\r\n     * Copied from core impress.js. We currently lack a library mechanism to\r\n     * to share utility functions like this.\r\n     */\r\n    var toNumber = function( numeric, fallback ) {\r\n        return isNaN( numeric ) ? ( fallback || 0 ) : Number( numeric );\r\n    };\r\n\r\n    /**\r\n     * Extends toNumber() to correctly compute also relative-to-screen-size values 5w and 5h.\r\n     *\r\n     * Returns the computed value in pixels with w/h postfix removed.\r\n     */\r\n    var toNumberAdvanced = function( numeric, fallback ) {\r\n        if ( typeof numeric !== \"string\" ) {\r\n            return toNumber( numeric, fallback );\r\n        }\r\n        var ratio = numeric.match( /^([+-]*[\\d\\.]+)([wh])$/ );\r\n        if ( ratio == null ) {\r\n            return toNumber( numeric, fallback );\r\n        } else {\r\n            var value = parseFloat( ratio[ 1 ] );\r\n            var multiplier = ratio[ 2 ] === \"w\" ? window.innerWidth : window.innerHeight;\r\n            return value * multiplier;\r\n        }\r\n    };\r\n\r\n    var computeRelativePositions = function( el, prev ) {\r\n        var data = el.dataset;\r\n\r\n        if ( !prev ) {\r\n\r\n            // For the first step, inherit these defaults\r\n            prev = { x:0, y:0, z:0, relative: { x:0, y:0, z:0 } };\r\n        }\r\n\r\n        if ( data.relTo ) {\r\n\r\n            var ref = document.getElementById( data.relTo );\r\n            if ( ref ) {\r\n\r\n                // Test, if it is a previous step that already has some assigned position data\r\n                if ( el.compareDocumentPosition( ref ) & Node.DOCUMENT_POSITION_PRECEDING ) {\r\n                    prev.x = toNumber( ref.getAttribute( \"data-x\" ) );\r\n                    prev.y = toNumber( ref.getAttribute( \"data-y\" ) );\r\n                    prev.z = toNumber( ref.getAttribute( \"data-z\" ) );\r\n                    prev.relative = {};\r\n                } else {\r\n                    window.console.error(\r\n                        \"impress.js rel plugin: Step \\\"\" + data.relTo + \"\\\" is not defined \" +\r\n                        \"*before* the current step. Referencing is limited to previously defined \" +\r\n                        \"steps. Please check your markup. Ignoring data-rel-to attribute of \" +\r\n                        \"this step. Have a look at the documentation for how to create relative \" +\r\n                        \"positioning to later shown steps with the help of the goto plugin.\"\r\n                    );\r\n                }\r\n            } else {\r\n\r\n                // Step not found\r\n                window.console.warn(\r\n                    \"impress.js rel plugin: \\\"\" + data.relTo + \"\\\" is not a valid step in this \" +\r\n                    \"impress.js presentation. Please check your markup. Ignoring data-rel-to \" +\r\n                    \"attribute of this step.\"\r\n                );\r\n            }\r\n        }\r\n\r\n        var step = {\r\n                x: toNumber( data.x, prev.x ),\r\n                y: toNumber( data.y, prev.y ),\r\n                z: toNumber( data.z, prev.z ),\r\n                relative: {\r\n                    x: toNumberAdvanced( data.relX, prev.relative.x ),\r\n                    y: toNumberAdvanced( data.relY, prev.relative.y ),\r\n                    z: toNumberAdvanced( data.relZ, prev.relative.z )\r\n                }\r\n            };\r\n\r\n        // Relative position is ignored/zero if absolute is given.\r\n        // Note that this also has the effect of resetting any inherited relative values.\r\n        if ( data.x !== undefined ) {\r\n            step.relative.x = 0;\r\n        }\r\n        if ( data.y !== undefined ) {\r\n            step.relative.y = 0;\r\n        }\r\n        if ( data.z !== undefined ) {\r\n            step.relative.z = 0;\r\n        }\r\n\r\n        // Apply relative position to absolute position, if non-zero\r\n        // Note that at this point, the relative values contain a number value of pixels.\r\n        step.x = step.x + step.relative.x;\r\n        step.y = step.y + step.relative.y;\r\n        step.z = step.z + step.relative.z;\r\n\r\n        return step;\r\n    };\r\n\r\n    var rel = function( root ) {\r\n        var steps = root.querySelectorAll( \".step\" );\r\n        var prev;\r\n        startingState[ root.id ] = [];\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            var el = steps[ i ];\r\n            startingState[ root.id ].push( {\r\n                el: el,\r\n                x: el.getAttribute( \"data-x\" ),\r\n                y: el.getAttribute( \"data-y\" ),\r\n                z: el.getAttribute( \"data-z\" ),\r\n                relX: el.getAttribute( \"data-rel-x\" ),\r\n                relY: el.getAttribute( \"data-rel-y\" ),\r\n                relZ: el.getAttribute( \"data-rel-z\" )\r\n            } );\r\n            var step = computeRelativePositions( el, prev );\r\n\r\n            // Apply relative position (if non-zero)\r\n            el.setAttribute( \"data-x\", step.x );\r\n            el.setAttribute( \"data-y\", step.y );\r\n            el.setAttribute( \"data-z\", step.z );\r\n            prev = step;\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-init phase\r\n    window.impress.addPreInitPlugin( rel );\r\n\r\n    // Register teardown callback to reset the data.x, .y, .z values.\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var root = event.target;\r\n        event.detail.api.lib.gc.pushCallback( function() {\r\n            var steps = startingState[ root.id ];\r\n            var step;\r\n            while ( step = steps.pop() ) {\r\n\r\n                // Reset x/y/z in cases where this plugin has changed it.\r\n                if ( step.relX !== null ) {\r\n                    if ( step.x === null ) {\r\n                        step.el.removeAttribute( \"data-x\" );\r\n                    } else {\r\n                        step.el.setAttribute( \"data-x\", step.x );\r\n                    }\r\n                }\r\n                if ( step.relY !== null ) {\r\n                    if ( step.y === null ) {\r\n                        step.el.removeAttribute( \"data-y\" );\r\n                    } else {\r\n                        step.el.setAttribute( \"data-y\", step.y );\r\n                    }\r\n                }\r\n                if ( step.relZ !== null ) {\r\n                    if ( step.z === null ) {\r\n                        step.el.removeAttribute( \"data-z\" );\r\n                    } else {\r\n                        step.el.setAttribute( \"data-z\", step.z );\r\n                    }\r\n                }\r\n            }\r\n            delete startingState[ root.id ];\r\n        } );\r\n    }, false );\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Resize plugin\r\n *\r\n * Rescale the presentation after a window resize.\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Released under the MIT license.\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka\r\n *  version: 0.5.3\r\n *  url:     http://bartaz.github.com/impress.js/\r\n *  source:  http://github.com/bartaz/impress.js/\r\n *\r\n */\r\n\r\n/* global document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var api = event.detail.api;\r\n\r\n        // Rescale presentation when window is resized\r\n        api.lib.gc.addEventListener( window, \"resize\", api.lib.util.throttle( function() {\r\n\r\n            // Force going to active step again, to trigger rescaling\r\n            api.goto( document.querySelector( \".step.active\" ), 500 );\r\n        }, 250 ), false );\r\n    }, false );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Skip Plugin\r\n *\r\n * Example:\r\n *\r\n *    <!-- This slide is disabled in presentations, when moving with next()\r\n *         and prev() commands, but you can still move directly to it, for\r\n *         example with a url (anything using goto()). -->\r\n *         <div class=\"step skip\">\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n\r\n/* global document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var util;\r\n\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        util = event.detail.api.lib.util;\r\n    }, false );\r\n\r\n    var getNextStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i + 1 < steps.length ) {\r\n                    return steps[ i + 1 ];\r\n                } else {\r\n                    return steps[ 0 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var getPrevStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = steps.length - 1; i >= 0; i-- ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i - 1 >= 0 ) {\r\n                    return steps[ i - 1 ];\r\n                } else {\r\n                    return steps[ steps.length - 1 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    var skip = function( event ) {\r\n        if ( ( !event ) || ( !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        if ( event.detail.next.classList.contains( \"skip\" ) ) {\r\n            if ( event.detail.reason === \"next\" ) {\r\n\r\n                // Go to the next next step instead\r\n                event.detail.next = getNextStep( event.detail.next );\r\n\r\n                // Recursively call this plugin again, until there's a step not to skip\r\n                skip( event );\r\n            } else if ( event.detail.reason === \"prev\" ) {\r\n\r\n                // Go to the previous previous step instead\r\n                event.detail.next = getPrevStep( event.detail.next );\r\n                skip( event );\r\n            }\r\n\r\n            // If the new next element has its own transitionDuration, we're responsible for setting\r\n            // that on the event as well\r\n            event.detail.transitionDuration = util.toNumber(\r\n                event.detail.next.dataset.transitionDuration, event.detail.transitionDuration\r\n            );\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-stepleave phase\r\n    // The weight makes this plugin run early. This is a good thing, because this plugin calls\r\n    // itself recursively.\r\n    window.impress.addPreStepLeavePlugin( skip, 1 );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Stop Plugin\r\n *\r\n * Example:\r\n *\r\n *        <!-- Stop at this slide.\r\n *             (For example, when used on the last slide, this prevents the\r\n *             presentation from wrapping back to the beginning.) -->\r\n *        <div class=\"step stop\">\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n/* global document, window */\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    var stop = function( event ) {\r\n        if ( ( !event ) || ( !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        if ( event.target.classList.contains( \"stop\" ) ) {\r\n            if ( event.detail.reason === \"next\" ) {\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-stepleave phase\r\n    // The weight makes this plugin run fairly early.\r\n    window.impress.addPreStepLeavePlugin( stop, 2 );\r\n\r\n} )( document, window );\r\n\r\n\r\n/**\r\n * Substep Plugin\r\n *\r\n * Copyright 2017 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n\r\n/* global document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    // Copied from core impress.js. Good candidate for moving to src/lib/util.js.\r\n    var triggerEvent = function( el, eventName, detail ) {\r\n        var event = document.createEvent( \"CustomEvent\" );\r\n        event.initCustomEvent( eventName, true, true, detail );\r\n        el.dispatchEvent( event );\r\n    };\r\n\r\n    var activeStep = null;\r\n    document.addEventListener( \"impress:stepenter\", function( event ) {\r\n        activeStep = event.target;\r\n    }, false );\r\n\r\n    var substep = function( event ) {\r\n        if ( ( !event ) || ( !event.target ) ) {\r\n            return;\r\n        }\r\n\r\n        var step = event.target;\r\n        var el; // Needed by jshint\r\n        if ( event.detail.reason === \"next\" ) {\r\n            el = showSubstepIfAny( step );\r\n            if ( el ) {\r\n\r\n                // Send a message to others, that we aborted a stepleave event.\r\n                triggerEvent( step, \"impress:substep:stepleaveaborted\",\r\n                              { reason: \"next\", substep: el } );\r\n\r\n                // Autoplay uses this for reloading itself\r\n                triggerEvent( step, \"impress:substep:enter\",\r\n                              { reason: \"next\", substep: el } );\r\n\r\n                // Returning false aborts the stepleave event\r\n                return false;\r\n            }\r\n        }\r\n        if ( event.detail.reason === \"prev\" ) {\r\n            el = hideSubstepIfAny( step );\r\n            if ( el ) {\r\n                triggerEvent( step, \"impress:substep:stepleaveaborted\",\r\n                              { reason: \"prev\", substep: el } );\r\n\r\n                triggerEvent( step, \"impress:substep:leave\",\r\n                              { reason: \"prev\", substep: el } );\r\n\r\n                return false;\r\n            }\r\n        }\r\n    };\r\n\r\n    var showSubstepIfAny = function( step ) {\r\n        var substeps = step.querySelectorAll( \".substep\" );\r\n        var visible = step.querySelectorAll( \".substep-visible\" );\r\n        if ( substeps.length > 0 ) {\r\n            return showSubstep( substeps, visible );\r\n        }\r\n    };\r\n\r\n    var showSubstep = function( substeps, visible ) {\r\n        if ( visible.length < substeps.length ) {\r\n            for ( var i = 0; i < substeps.length; i++ ) {\r\n                substeps[ i ].classList.remove( \"substep-active\" );\r\n            }\r\n            var el = substeps[ visible.length ];\r\n            el.classList.add( \"substep-visible\" );\r\n            el.classList.add( \"substep-active\" );\r\n            return el;\r\n        }\r\n    };\r\n\r\n    var hideSubstepIfAny = function( step ) {\r\n        var substeps = step.querySelectorAll( \".substep\" );\r\n        var visible = step.querySelectorAll( \".substep-visible\" );\r\n        if ( substeps.length > 0 ) {\r\n            return hideSubstep( visible );\r\n        }\r\n    };\r\n\r\n    var hideSubstep = function( visible ) {\r\n        if ( visible.length > 0 ) {\r\n            var current = -1;\r\n            for ( var i = 0; i < visible.length; i++ ) {\r\n                if ( visible[ i ].classList.contains( \"substep-active\" ) ) {\r\n                    current = i;\r\n                }\r\n                visible[ i ].classList.remove( \"substep-active\" );\r\n            }\r\n            if ( current > 0 ) {\r\n                visible[ current - 1 ].classList.add( \"substep-active\" );\r\n            }\r\n            var el = visible[ visible.length - 1 ];\r\n            el.classList.remove( \"substep-visible\" );\r\n            return el;\r\n        }\r\n    };\r\n\r\n    // Register the plugin to be called in pre-stepleave phase.\r\n    // The weight makes this plugin run before other preStepLeave plugins.\r\n    window.impress.addPreStepLeavePlugin( substep, 1 );\r\n\r\n    // When entering a step, in particular when re-entering, make sure that all substeps are hidden\r\n    // at first\r\n    document.addEventListener( \"impress:stepenter\", function( event ) {\r\n        var step = event.target;\r\n        var visible = step.querySelectorAll( \".substep-visible\" );\r\n        for ( var i = 0; i < visible.length; i++ ) {\r\n            visible[ i ].classList.remove( \"substep-visible\" );\r\n        }\r\n    }, false );\r\n\r\n    // API for others to reveal/hide next substep ////////////////////////////////////////////////\r\n    document.addEventListener( \"impress:substep:show\", function() {\r\n        showSubstepIfAny( activeStep );\r\n    }, false );\r\n\r\n    document.addEventListener( \"impress:substep:hide\", function() {\r\n        hideSubstepIfAny( activeStep );\r\n    }, false );\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Support for swipe and tap on touch devices\r\n *\r\n * This plugin implements navigation for plugin devices, via swiping left/right,\r\n * or tapping on the left/right edges of the screen.\r\n *\r\n *\r\n *\r\n * Copyright 2015: Andrew Dunai (@and3rson)\r\n * Modified to a plugin, 2016: Henrik Ingo (@henrikingo)\r\n *\r\n * MIT License\r\n */\r\n/* global document, window */\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    // Touch handler to detect swiping left and right based on window size.\r\n    // If the difference in X change is bigger than 1/20 of the screen width,\r\n    // we simply call an appropriate API function to complete the transition.\r\n    var startX = 0;\r\n    var lastX = 0;\r\n    var lastDX = 0;\r\n    var threshold = window.innerWidth / 20;\r\n\r\n    document.addEventListener( \"touchstart\", function( event ) {\r\n        lastX = startX = event.touches[ 0 ].clientX;\r\n    } );\r\n\r\n    document.addEventListener( \"touchmove\", function( event ) {\r\n         var x = event.touches[ 0 ].clientX;\r\n         var diff = x - startX;\r\n\r\n         // To be used in touchend\r\n         lastDX = lastX - x;\r\n         lastX = x;\r\n\r\n         window.impress().swipe( diff / window.innerWidth );\r\n     } );\r\n\r\n     document.addEventListener( \"touchend\", function() {\r\n         var totalDiff = lastX - startX;\r\n         if ( Math.abs( totalDiff ) > window.innerWidth / 5 && ( totalDiff * lastDX ) <= 0 ) {\r\n             if ( totalDiff > window.innerWidth / 5 && lastDX <= 0 ) {\r\n                 window.impress().prev();\r\n             } else if ( totalDiff < -window.innerWidth / 5 && lastDX >= 0 ) {\r\n                 window.impress().next();\r\n             }\r\n         } else if ( Math.abs( lastDX ) > threshold ) {\r\n             if ( lastDX < -threshold ) {\r\n                 window.impress().prev();\r\n             } else if ( lastDX > threshold ) {\r\n                 window.impress().next();\r\n             }\r\n         } else {\r\n\r\n             // No movement - move (back) to the current slide\r\n             window.impress().goto( document.querySelector( \"#impress .step.active\" ) );\r\n         }\r\n     } );\r\n\r\n     document.addEventListener( \"touchcancel\", function() {\r\n\r\n             // Move (back) to the current slide\r\n             window.impress().goto( document.querySelector( \"#impress .step.active\" ) );\r\n     } );\r\n\r\n} )( document, window );\r\n\r\n/**\r\n * Toolbar plugin\r\n *\r\n * This plugin provides a generic graphical toolbar. Other plugins that\r\n * want to expose a button or other widget, can add those to this toolbar.\r\n *\r\n * Using a single consolidated toolbar for all GUI widgets makes it easier\r\n * to position and style the toolbar rather than having to do that for lots\r\n * of different divs.\r\n *\r\n *\r\n * *** For presentation authors: *****************************************\r\n *\r\n * To add/activate the toolbar in your presentation, add this div:\r\n *\r\n *     <div id=\"impress-toolbar\"></div>\r\n *\r\n * Styling the toolbar is left to presentation author. Here's an example CSS:\r\n *\r\n *    .impress-enabled div#impress-toolbar {\r\n *        position: fixed;\r\n *        right: 1px;\r\n *        bottom: 1px;\r\n *        opacity: 0.6;\r\n *    }\r\n *    .impress-enabled div#impress-toolbar > span {\r\n *        margin-right: 10px;\r\n *    }\r\n *\r\n * The [mouse-timeout](../mouse-timeout/README.md) plugin can be leveraged to hide\r\n * the toolbar from sight, and only make it visible when mouse is moved.\r\n *\r\n *    body.impress-mouse-timeout div#impress-toolbar {\r\n *        display: none;\r\n *    }\r\n *\r\n *\r\n * *** For plugin authors **********************************************\r\n *\r\n * To add a button to the toolbar, trigger the `impress:toolbar:appendChild`\r\n * or `impress:toolbar:insertBefore` events as appropriate. The detail object\r\n * should contain following parameters:\r\n *\r\n *    { group : 1,                       // integer. Widgets with the same group are grouped inside\r\n *                                       // the same <span> element.\r\n *      html : \"<button>Click</button>\", // The html to add.\r\n *      callback : \"mycallback\",         // Toolbar plugin will trigger event\r\n *                                       // `impress:toolbar:added:mycallback` when done.\r\n *      before: element }                // The reference element for an insertBefore() call.\r\n *\r\n * You should also listen to the `impress:toolbar:added:mycallback` event. At\r\n * this point you can find the new widget in the DOM, and for example add an\r\n * event listener to it.\r\n *\r\n * You are free to use any integer for the group. It's ok to leave gaps. It's\r\n * ok to co-locate with widgets for another plugin, if you think they belong\r\n * together.\r\n *\r\n * See navigation-ui for an example.\r\n *\r\n * Copyright 2016 Henrik Ingo (@henrikingo)\r\n * Released under the MIT license.\r\n */\r\n\r\n/* global document */\r\n\r\n( function( document ) {\r\n    \"use strict\";\r\n    var toolbar = document.getElementById( \"impress-toolbar\" );\r\n    var groups = [];\r\n\r\n    /**\r\n     * Get the span element that is a child of toolbar, identified by index.\r\n     *\r\n     * If span element doesn't exist yet, it is created.\r\n     *\r\n     * Note: Because of Run-to-completion, this is not a race condition.\r\n     * https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop#Run-to-completion\r\n     *\r\n     * :param: index   Method will return the element <span id=\"impress-toolbar-group-{index}\">\r\n     */\r\n    var getGroupElement = function( index ) {\r\n        var id = \"impress-toolbar-group-\" + index;\r\n        if ( !groups[ index ] ) {\r\n            groups[ index ] = document.createElement( \"span\" );\r\n            groups[ index ].id = id;\r\n            var nextIndex = getNextGroupIndex( index );\r\n            if ( nextIndex === undefined ) {\r\n                toolbar.appendChild( groups[ index ] );\r\n            } else {\r\n                toolbar.insertBefore( groups[ index ], groups[ nextIndex ] );\r\n            }\r\n        }\r\n        return groups[ index ];\r\n    };\r\n\r\n    /**\r\n     * Get the span element from groups[] that is immediately after given index.\r\n     *\r\n     * This can be used to find the reference node for an insertBefore() call.\r\n     * If no element exists at a larger index, returns undefined. (In this case,\r\n     * you'd use appendChild() instead.)\r\n     *\r\n     * Note that index needn't itself exist in groups[].\r\n     */\r\n    var getNextGroupIndex = function( index ) {\r\n        var i = index + 1;\r\n        while ( !groups[ i ] && i < groups.length ) {\r\n            i++;\r\n        }\r\n        if ( i < groups.length ) {\r\n            return i;\r\n        }\r\n    };\r\n\r\n    // API\r\n    // Other plugins can add and remove buttons by sending them as events.\r\n    // In return, toolbar plugin will trigger events when button was added.\r\n    if ( toolbar ) {\r\n        /**\r\n         * Append a widget inside toolbar span element identified by given group index.\r\n         *\r\n         * :param: e.detail.group    integer specifying the span element where widget will be placed\r\n         * :param: e.detail.element  a dom element to add to the toolbar\r\n         */\r\n        toolbar.addEventListener( \"impress:toolbar:appendChild\", function( e ) {\r\n            var group = getGroupElement( e.detail.group );\r\n            group.appendChild( e.detail.element );\r\n        } );\r\n\r\n        /**\r\n         * Add a widget to toolbar using insertBefore() DOM method.\r\n         *\r\n         * :param: e.detail.before   the reference dom element, before which new element is added\r\n         * :param: e.detail.element  a dom element to add to the toolbar\r\n         */\r\n        toolbar.addEventListener( \"impress:toolbar:insertBefore\", function( e ) {\r\n            toolbar.insertBefore( e.detail.element, e.detail.before );\r\n        } );\r\n\r\n        /**\r\n         * Remove the widget in e.detail.remove.\r\n         */\r\n        toolbar.addEventListener( \"impress:toolbar:removeWidget\", function( e ) {\r\n            toolbar.removeChild( e.detail.remove );\r\n        } );\r\n\r\n        document.addEventListener( \"impress:init\", function( event ) {\r\n            var api = event.detail.api;\r\n            api.lib.gc.pushCallback( function() {\r\n                toolbar.innerHTML = \"\";\r\n                groups = [];\r\n            } );\r\n        } );\r\n    } // If toolbar\r\n\r\n} )( document );\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress.js?");

/***/ }),

/***/ "./src/scripts/hint.js":
/*!*****************************!*\
  !*** ./src/scripts/hint.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const hint = document.querySelector(\".hint\");\r\n\r\nif (\"ontouchstart\" in document.documentElement) {\r\n  hint.innerHTML = \"Swipe left to start\";\r\n} else {\r\n  hint.innerHTML =\"Use a spacebar or arrow keys to navigate\";\r\n}\r\n\n\n//# sourceURL=webpack:///./src/scripts/hint.js?");

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/styles/index.scss?");

/***/ }),

/***/ 0:
/*!*******************************************************!*\
  !*** multi ./src/libraries/impress.js ./src/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! ./src/libraries/impress.js */\"./src/libraries/impress.js\");\nmodule.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/libraries/impress.js_./src/index.js?");

/***/ })

/******/ });