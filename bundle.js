/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/icons/at-solid.svg":
/*!********************************!*\
  !*** ./src/icons/at-solid.svg ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"at-solid.svg\");\n\n//# sourceURL=webpack:///./src/icons/at-solid.svg?");

/***/ }),

/***/ "./src/icons/github-brands.svg":
/*!*************************************!*\
  !*** ./src/icons/github-brands.svg ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"github-brands.svg\");\n\n//# sourceURL=webpack:///./src/icons/github-brands.svg?");

/***/ }),

/***/ "./src/icons/linkedin-brands.svg":
/*!***************************************!*\
  !*** ./src/icons/linkedin-brands.svg ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"linkedin-brands.svg\");\n\n//# sourceURL=webpack:///./src/icons/linkedin-brands.svg?");

/***/ }),

/***/ "./src/index.html":
/*!************************!*\
  !*** ./src/index.html ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (__webpack_require__.p + \"index.html\");\n\n//# sourceURL=webpack:///./src/index.html?");

/***/ }),

/***/ "./src/libraries/impress/impress.js":
/*!******************************************!*\
  !*** ./src/libraries/impress/impress.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*! Licensed under MIT License - http://github.com/impress/impress.js */\r\n/**\r\n * impress.js\r\n *\r\n * impress.js is a presentation tool based on the power of CSS3 transforms and transitions\r\n * in modern browsers and inspired by the idea behind prezi.com.\r\n *\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz), 2016-2018 Henrik Ingo (@henrikingo)\r\n *\r\n * Released under the MIT License.\r\n *\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka, Henrik Ingo\r\n *  version: 1.0.0\r\n *  url:     http://impress.js.org\r\n *  source:  http://github.com/impress/impress.js/\r\n */\r\n\r\n// You are one of those who like to know how things work inside?\r\n// Let me show you the cogs that make impress.js run...\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var lib;\r\n\r\n    // HELPER FUNCTIONS\r\n\r\n    // `pfx` is a function that takes a standard CSS property name as a parameter\r\n    // and returns it's prefixed version valid for current browser it runs in.\r\n    // The code is heavily inspired by Modernizr http://www.modernizr.com/\r\n    var pfx = ( function() {\r\n\r\n        var style = document.createElement( \"dummy\" ).style,\r\n            prefixes = \"Webkit Moz O ms Khtml\".split( \" \" ),\r\n            memory = {};\r\n\r\n        return function( prop ) {\r\n            if ( typeof memory[ prop ] === \"undefined\" ) {\r\n\r\n                var ucProp  = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),\r\n                    props   = ( prop + \" \" + prefixes.join( ucProp + \" \" ) + ucProp ).split( \" \" );\r\n\r\n                memory[ prop ] = null;\r\n                for ( var i in props ) {\r\n                    if ( style[ props[ i ] ] !== undefined ) {\r\n                        memory[ prop ] = props[ i ];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n            }\r\n\r\n            return memory[ prop ];\r\n        };\r\n\r\n    } )();\r\n\r\n    var validateOrder = function( order, fallback ) {\r\n        var validChars = \"xyz\";\r\n        var returnStr = \"\";\r\n        if ( typeof order === \"string\" ) {\r\n            for ( var i in order.split( \"\" ) ) {\r\n                if ( validChars.indexOf( order[ i ] ) >= 0 ) {\r\n                    returnStr += order[ i ];\r\n\r\n                    // Each of x,y,z can be used only once.\r\n                    validChars = validChars.split( order[ i ] ).join( \"\" );\r\n                }\r\n            }\r\n        }\r\n        if ( returnStr ) {\r\n            return returnStr;\r\n        } else if ( fallback !== undefined ) {\r\n            return fallback;\r\n        } else {\r\n            return \"xyz\";\r\n        }\r\n    };\r\n\r\n    // `css` function applies the styles given in `props` object to the element\r\n    // given as `el`. It runs all property names through `pfx` function to make\r\n    // sure proper prefixed version of the property is used.\r\n    var css = function( el, props ) {\r\n        var key, pkey;\r\n        for ( key in props ) {\r\n            if ( props.hasOwnProperty( key ) ) {\r\n                pkey = pfx( key );\r\n                if ( pkey !== null ) {\r\n                    el.style[ pkey ] = props[ key ];\r\n                }\r\n            }\r\n        }\r\n        return el;\r\n    };\r\n\r\n    // `translate` builds a translate transform string for given data.\r\n    var translate = function( t ) {\r\n        return \" translate3d(\" + t.x + \"px,\" + t.y + \"px,\" + t.z + \"px) \";\r\n    };\r\n\r\n    // `rotate` builds a rotate transform string for given data.\r\n    // By default the rotations are in X Y Z order that can be reverted by passing `true`\r\n    // as second parameter.\r\n    var rotate = function( r, revert ) {\r\n        var order = r.order ? r.order : \"xyz\";\r\n        var css = \"\";\r\n        var axes = order.split( \"\" );\r\n        if ( revert ) {\r\n            axes = axes.reverse();\r\n        }\r\n\r\n        for ( var i = 0; i < axes.length; i++ ) {\r\n            css += \" rotate\" + axes[ i ].toUpperCase() + \"(\" + r[ axes[ i ] ] + \"deg)\";\r\n        }\r\n        return css;\r\n    };\r\n\r\n    // `scale` builds a scale transform string for given data.\r\n    var scale = function( s ) {\r\n        return \" scale(\" + s + \") \";\r\n    };\r\n\r\n    // `computeWindowScale` counts the scale factor between window size and size\r\n    // defined for the presentation in the config.\r\n    var computeWindowScale = function( config ) {\r\n        var hScale = window.innerHeight / config.height,\r\n            wScale = window.innerWidth / config.width,\r\n            scale = hScale > wScale ? wScale : hScale;\r\n\r\n        if ( config.maxScale && scale > config.maxScale ) {\r\n            scale = config.maxScale;\r\n        }\r\n\r\n        if ( config.minScale && scale < config.minScale ) {\r\n            scale = config.minScale;\r\n        }\r\n\r\n        return scale;\r\n    };\r\n\r\n    // CHECK SUPPORT\r\n    var body = document.body;\r\n    var impressSupported =\r\n\r\n                          // Browser should support CSS 3D transtorms\r\n                           ( pfx( \"perspective\" ) !== null ) &&\r\n\r\n                          // And `classList` and `dataset` APIs\r\n                           ( body.classList ) &&\r\n                           ( body.dataset );\r\n\r\n    if ( !impressSupported ) {\r\n\r\n        // We can't be sure that `classList` is supported\r\n        body.className += \" impress-not-supported \";\r\n    }\r\n\r\n    // GLOBALS AND DEFAULTS\r\n\r\n    // This is where the root elements of all impress.js instances will be kept.\r\n    // Yes, this means you can have more than one instance on a page, but I'm not\r\n    // sure if it makes any sense in practice ;)\r\n    var roots = {};\r\n\r\n    var preInitPlugins = [];\r\n    var preStepLeavePlugins = [];\r\n\r\n    // Some default config values.\r\n    var defaults = {\r\n        width: 1024,\r\n        height: 768,\r\n        maxScale: 1,\r\n        minScale: 0,\r\n\r\n        perspective: 1000,\r\n\r\n        transitionDuration: 1000\r\n    };\r\n\r\n    // It's just an empty function ... and a useless comment.\r\n    var empty = function() { return false; };\r\n\r\n    // IMPRESS.JS API\r\n\r\n    // And that's where interesting things will start to happen.\r\n    // It's the core `impress` function that returns the impress.js API\r\n    // for a presentation based on the element with given id (\"impress\"\r\n    // by default).\r\n    var impress = window.impress = function( rootId ) {\r\n\r\n        // If impress.js is not supported by the browser return a dummy API\r\n        // it may not be a perfect solution but we return early and avoid\r\n        // running code that may use features not implemented in the browser.\r\n        if ( !impressSupported ) {\r\n            return {\r\n                init: empty,\r\n                goto: empty,\r\n                prev: empty,\r\n                next: empty,\r\n                swipe: empty,\r\n                tear: empty,\r\n                lib: {}\r\n            };\r\n        }\r\n\r\n        rootId = rootId || \"impress\";\r\n\r\n        // If given root is already initialized just return the API\r\n        if ( roots[ \"impress-root-\" + rootId ] ) {\r\n            return roots[ \"impress-root-\" + rootId ];\r\n        }\r\n\r\n        // The gc library depends on being initialized before we do any changes to DOM.\r\n        lib = initLibraries( rootId );\r\n\r\n        body.classList.remove( \"impress-not-supported\" );\r\n        body.classList.add( \"impress-supported\" );\r\n\r\n        // Data of all presentation steps\r\n        var stepsData = {};\r\n\r\n        // Element of currently active step\r\n        var activeStep = null;\r\n\r\n        // Current state (position, rotation and scale) of the presentation\r\n        var currentState = null;\r\n\r\n        // Array of step elements\r\n        var steps = null;\r\n\r\n        // Configuration options\r\n        var config = null;\r\n\r\n        // Scale factor of the browser window\r\n        var windowScale = null;\r\n\r\n        // Root presentation elements\r\n        var root = lib.util.byId( rootId );\r\n        var canvas = document.createElement( \"div\" );\r\n\r\n        var initialized = false;\r\n\r\n        // STEP EVENTS\r\n        //\r\n        // There are currently two step events triggered by impress.js\r\n        // `impress:stepenter` is triggered when the step is shown on the\r\n        // screen (the transition from the previous one is finished) and\r\n        // `impress:stepleave` is triggered when the step is left (the\r\n        // transition to next step just starts).\r\n\r\n        // Reference to last entered step\r\n        var lastEntered = null;\r\n\r\n        // `onStepEnter` is called whenever the step element is entered\r\n        // but the event is triggered only if the step is different than\r\n        // last entered step.\r\n        // We sometimes call `goto`, and therefore `onStepEnter`, just to redraw a step, such as\r\n        // after screen resize. In this case - more precisely, in any case - we trigger a\r\n        // `impress:steprefresh` event.\r\n        var onStepEnter = function( step ) {\r\n            if ( lastEntered !== step ) {\r\n                lib.util.triggerEvent( step, \"impress:stepenter\" );\r\n                lastEntered = step;\r\n            }\r\n            lib.util.triggerEvent( step, \"impress:steprefresh\" );\r\n        };\r\n\r\n        // `onStepLeave` is called whenever the currentStep element is left\r\n        // but the event is triggered only if the currentStep is the same as\r\n        // lastEntered step.\r\n        var onStepLeave = function( currentStep, nextStep ) {\r\n            if ( lastEntered === currentStep ) {\r\n                lib.util.triggerEvent( currentStep, \"impress:stepleave\", { next: nextStep } );\r\n                lastEntered = null;\r\n            }\r\n        };\r\n\r\n        // `initStep` initializes given step element by reading data from its\r\n        // data attributes and setting correct styles.\r\n        var initStep = function( el, idx ) {\r\n            var data = el.dataset,\r\n                step = {\r\n                    translate: {\r\n                        x: lib.util.toNumber( data.x ),\r\n                        y: lib.util.toNumber( data.y ),\r\n                        z: lib.util.toNumber( data.z )\r\n                    },\r\n                    rotate: {\r\n                        x: lib.util.toNumber( data.rotateX ),\r\n                        y: lib.util.toNumber( data.rotateY ),\r\n                        z: lib.util.toNumber( data.rotateZ || data.rotate ),\r\n                        order: validateOrder( data.rotateOrder )\r\n                    },\r\n                    scale: lib.util.toNumber( data.scale, 1 ),\r\n                    transitionDuration: lib.util.toNumber(\r\n                        data.transitionDuration, config.transitionDuration\r\n                    ),\r\n                    el: el\r\n                };\r\n\r\n            if ( !el.id ) {\r\n                el.id = \"step-\" + ( idx + 1 );\r\n            }\r\n\r\n            stepsData[ \"impress-\" + el.id ] = step;\r\n\r\n            css( el, {\r\n                position: \"absolute\",\r\n                transform: \"translate(-50%,-50%)\" +\r\n                           translate( step.translate ) +\r\n                           rotate( step.rotate ) +\r\n                           scale( step.scale ),\r\n                transformStyle: \"preserve-3d\"\r\n            } );\r\n        };\r\n\r\n        // Initialize all steps.\r\n        // Read the data-* attributes, store in internal stepsData, and render with CSS.\r\n        var initAllSteps = function() {\r\n            steps = lib.util.$$( \".step\", root );\r\n            steps.forEach( initStep );\r\n        };\r\n\r\n        // `init` API function that initializes (and runs) the presentation.\r\n        var init = function() {\r\n            if ( initialized ) { return; }\r\n            execPreInitPlugins( root );\r\n\r\n            // First we set up the viewport for mobile devices.\r\n            // For some reason iPad goes nuts when it is not done properly.\r\n            var meta = lib.util.$( \"meta[name='viewport']\" ) || document.createElement( \"meta\" );\r\n            meta.content = \"width=device-width, minimum-scale=1, maximum-scale=1, user-scalable=no\";\r\n            if ( meta.parentNode !== document.head ) {\r\n                meta.name = \"viewport\";\r\n                document.head.appendChild( meta );\r\n            }\r\n\r\n            // Initialize configuration object\r\n            var rootData = root.dataset;\r\n            config = {\r\n                width: lib.util.toNumber( rootData.width, defaults.width ),\r\n                height: lib.util.toNumber( rootData.height, defaults.height ),\r\n                maxScale: lib.util.toNumber( rootData.maxScale, defaults.maxScale ),\r\n                minScale: lib.util.toNumber( rootData.minScale, defaults.minScale ),\r\n                perspective: lib.util.toNumber( rootData.perspective, defaults.perspective ),\r\n                transitionDuration: lib.util.toNumber(\r\n                    rootData.transitionDuration, defaults.transitionDuration\r\n                )\r\n            };\r\n\r\n            windowScale = computeWindowScale( config );\r\n\r\n            // Wrap steps with \"canvas\" element\r\n            lib.util.arrayify( root.childNodes ).forEach( function( el ) {\r\n                canvas.appendChild( el );\r\n            } );\r\n            root.appendChild( canvas );\r\n\r\n            // Set initial styles\r\n            document.documentElement.style.height = \"100%\";\r\n\r\n            css( body, {\r\n                height: \"100%\",\r\n                overflow: \"hidden\"\r\n            } );\r\n\r\n            var rootStyles = {\r\n                position: \"absolute\",\r\n                transformOrigin: \"top left\",\r\n                transition: \"all 0s ease-in-out\",\r\n                transformStyle: \"preserve-3d\"\r\n            };\r\n\r\n            css( root, rootStyles );\r\n            css( root, {\r\n                top: \"50%\",\r\n                left: \"50%\",\r\n                perspective: ( config.perspective / windowScale ) + \"px\",\r\n                transform: scale( windowScale )\r\n            } );\r\n            css( canvas, rootStyles );\r\n\r\n            body.classList.remove( \"impress-disabled\" );\r\n            body.classList.add( \"impress-enabled\" );\r\n\r\n            // Get and init steps\r\n            initAllSteps();\r\n\r\n            // Set a default initial state of the canvas\r\n            currentState = {\r\n                translate: { x: 0, y: 0, z: 0 },\r\n                rotate:    { x: 0, y: 0, z: 0, order: \"xyz\" },\r\n                scale:     1\r\n            };\r\n\r\n            initialized = true;\r\n\r\n            lib.util.triggerEvent( root, \"impress:init\",\r\n                                   { api: roots[ \"impress-root-\" + rootId ] } );\r\n        };\r\n\r\n        // `getStep` is a helper function that returns a step element defined by parameter.\r\n        // If a number is given, step with index given by the number is returned, if a string\r\n        // is given step element with such id is returned, if DOM element is given it is returned\r\n        // if it is a correct step element.\r\n        var getStep = function( step ) {\r\n            if ( typeof step === \"number\" ) {\r\n                step = step < 0 ? steps[ steps.length + step ] : steps[ step ];\r\n            } else if ( typeof step === \"string\" ) {\r\n                step = lib.util.byId( step );\r\n            }\r\n            return ( step && step.id && stepsData[ \"impress-\" + step.id ] ) ? step : null;\r\n        };\r\n\r\n        // Used to reset timeout for `impress:stepenter` event\r\n        var stepEnterTimeout = null;\r\n\r\n        // `goto` API function that moves to step given as `el` parameter (by index, id or element).\r\n        // `duration` optionally given as second parameter, is the transition duration in css.\r\n        // `reason` is the string \"next\", \"prev\" or \"goto\" (default) and will be made available to\r\n        // preStepLeave plugins.\r\n        // `origEvent` may contain event that caused the call to goto, such as a key press event\r\n        var goto = function( el, duration, reason, origEvent ) {\r\n            reason = reason || \"goto\";\r\n            origEvent = origEvent || null;\r\n\r\n            if ( !initialized ) {\r\n                return false;\r\n            }\r\n\r\n            // Re-execute initAllSteps for each transition. This allows to edit step attributes\r\n            // dynamically, such as change their coordinates, or even remove or add steps, and have\r\n            // that change apply when goto() is called.\r\n            initAllSteps();\r\n\r\n            if ( !( el = getStep( el ) ) ) {\r\n                return false;\r\n            }\r\n\r\n            // Sometimes it's possible to trigger focus on first link with some keyboard action.\r\n            // Browser in such a case tries to scroll the page to make this element visible\r\n            // (even that body overflow is set to hidden) and it breaks our careful positioning.\r\n            //\r\n            // So, as a lousy (and lazy) workaround we will make the page scroll back to the top\r\n            // whenever slide is selected\r\n            //\r\n            // If you are reading this and know any better way to handle it, I'll be glad to hear\r\n            // about it!\r\n            window.scrollTo( 0, 0 );\r\n\r\n            var step = stepsData[ \"impress-\" + el.id ];\r\n            duration = ( duration !== undefined ? duration : step.transitionDuration );\r\n\r\n            // If we are in fact moving to another step, start with executing the registered\r\n            // preStepLeave plugins.\r\n            if ( activeStep && activeStep !== el ) {\r\n                var event = { target: activeStep, detail: {} };\r\n                event.detail.next = el;\r\n                event.detail.transitionDuration = duration;\r\n                event.detail.reason = reason;\r\n                if ( origEvent ) {\r\n                    event.origEvent = origEvent;\r\n                }\r\n\r\n                if ( execPreStepLeavePlugins( event ) === false ) {\r\n\r\n                    // PreStepLeave plugins are allowed to abort the transition altogether, by\r\n                    // returning false.\r\n                    // see stop and substep plugins for an example of doing just that\r\n                    return false;\r\n                }\r\n\r\n                // Plugins are allowed to change the detail values\r\n                el = event.detail.next;\r\n                step = stepsData[ \"impress-\" + el.id ];\r\n                duration = event.detail.transitionDuration;\r\n            }\r\n\r\n            if ( activeStep ) {\r\n                activeStep.classList.remove( \"active\" );\r\n                body.classList.remove( \"impress-on-\" + activeStep.id );\r\n            }\r\n            el.classList.add( \"active\" );\r\n\r\n            body.classList.add( \"impress-on-\" + el.id );\r\n\r\n            // Compute target state of the canvas based on given step\r\n            var target = {\r\n                rotate: {\r\n                    x: -step.rotate.x,\r\n                    y: -step.rotate.y,\r\n                    z: -step.rotate.z,\r\n                    order: step.rotate.order\r\n                },\r\n                translate: {\r\n                    x: -step.translate.x,\r\n                    y: -step.translate.y,\r\n                    z: -step.translate.z\r\n                },\r\n                scale: 1 / step.scale\r\n            };\r\n\r\n            // Check if the transition is zooming in or not.\r\n            //\r\n            // This information is used to alter the transition style:\r\n            // when we are zooming in - we start with move and rotate transition\r\n            // and the scaling is delayed, but when we are zooming out we start\r\n            // with scaling down and move and rotation are delayed.\r\n            var zoomin = target.scale >= currentState.scale;\r\n\r\n            duration = lib.util.toNumber( duration, config.transitionDuration );\r\n            var delay = ( duration / 2 );\r\n\r\n            // If the same step is re-selected, force computing window scaling,\r\n            // because it is likely to be caused by window resize\r\n            if ( el === activeStep ) {\r\n                windowScale = computeWindowScale( config );\r\n            }\r\n\r\n            var targetScale = target.scale * windowScale;\r\n\r\n            // Trigger leave of currently active element (if it's not the same step again)\r\n            if ( activeStep && activeStep !== el ) {\r\n                onStepLeave( activeStep, el );\r\n            }\r\n\r\n            // Now we alter transforms of `root` and `canvas` to trigger transitions.\r\n            //\r\n            // And here is why there are two elements: `root` and `canvas` - they are\r\n            // being animated separately:\r\n            // `root` is used for scaling and `canvas` for translate and rotations.\r\n            // Transitions on them are triggered with different delays (to make\r\n            // visually nice and \"natural\" looking transitions), so we need to know\r\n            // that both of them are finished.\r\n            css( root, {\r\n\r\n                // To keep the perspective look similar for different scales\r\n                // we need to \"scale\" the perspective, too\r\n                // For IE 11 support we must specify perspective independent\r\n                // of transform.\r\n                perspective: ( config.perspective / targetScale ) + \"px\",\r\n                transform: scale( targetScale ),\r\n                transitionDuration: duration + \"ms\",\r\n                transitionDelay: ( zoomin ? delay : 0 ) + \"ms\"\r\n            } );\r\n\r\n            css( canvas, {\r\n                transform: rotate( target.rotate, true ) + translate( target.translate ),\r\n                transitionDuration: duration + \"ms\",\r\n                transitionDelay: ( zoomin ? 0 : delay ) + \"ms\"\r\n            } );\r\n\r\n            // Here is a tricky part...\r\n            //\r\n            // If there is no change in scale or no change in rotation and translation, it means\r\n            // there was actually no delay - because there was no transition on `root` or `canvas`\r\n            // elements. We want to trigger `impress:stepenter` event in the correct moment, so\r\n            // here we compare the current and target values to check if delay should be taken into\r\n            // account.\r\n            //\r\n            // I know that this `if` statement looks scary, but it's pretty simple when you know\r\n            // what is going on - it's simply comparing all the values.\r\n            if ( currentState.scale === target.scale ||\r\n                ( currentState.rotate.x === target.rotate.x &&\r\n                  currentState.rotate.y === target.rotate.y &&\r\n                  currentState.rotate.z === target.rotate.z &&\r\n                  currentState.translate.x === target.translate.x &&\r\n                  currentState.translate.y === target.translate.y &&\r\n                  currentState.translate.z === target.translate.z ) ) {\r\n                delay = 0;\r\n            }\r\n\r\n            // Store current state\r\n            currentState = target;\r\n            activeStep = el;\r\n\r\n            // And here is where we trigger `impress:stepenter` event.\r\n            // We simply set up a timeout to fire it taking transition duration (and possible delay)\r\n            // into account.\r\n            //\r\n            // I really wanted to make it in more elegant way. The `transitionend` event seemed to\r\n            // be the best way to do it, but the fact that I'm using transitions on two separate\r\n            // elements and that the `transitionend` event is only triggered when there was a\r\n            // transition (change in the values) caused some bugs and made the code really\r\n            // complicated, cause I had to handle all the conditions separately. And it still\r\n            // needed a `setTimeout` fallback for the situations when there is no transition at all.\r\n            // So I decided that I'd rather make the code simpler than use shiny new\r\n            // `transitionend`.\r\n            //\r\n            // If you want learn something interesting and see how it was done with `transitionend`\r\n            // go back to version 0.5.2 of impress.js:\r\n            // http://github.com/bartaz/impress.js/blob/0.5.2/js/impress.js\r\n            window.clearTimeout( stepEnterTimeout );\r\n            stepEnterTimeout = window.setTimeout( function() {\r\n                onStepEnter( activeStep );\r\n            }, duration + delay );\r\n\r\n            return el;\r\n        };\r\n\r\n        // `prev` API function goes to previous step (in document order)\r\n        // `event` is optional, may contain the event that caused the need to call prev()\r\n        var prev = function( origEvent ) {\r\n            var prev = steps.indexOf( activeStep ) - 1;\r\n            prev = prev >= 0 ? steps[ prev ] : steps[ steps.length - 1 ];\r\n\r\n            return goto( prev, undefined, \"prev\", origEvent );\r\n        };\r\n\r\n        // `next` API function goes to next step (in document order)\r\n        // `event` is optional, may contain the event that caused the need to call next()\r\n        var next = function( origEvent ) {\r\n            var next = steps.indexOf( activeStep ) + 1;\r\n            next = next < steps.length ? steps[ next ] : steps[ 0 ];\r\n\r\n            return goto( next, undefined, \"next\", origEvent );\r\n        };\r\n\r\n        // Swipe for touch devices by @and3rson.\r\n        // Below we extend the api to control the animation between the currently\r\n        // active step and a presumed next/prev step. See touch plugin for\r\n        // an example of using this api.\r\n\r\n        // Helper function\r\n        var interpolate = function( a, b, k ) {\r\n            return a + ( b - a ) * k;\r\n        };\r\n\r\n        // Animate a swipe.\r\n        //\r\n        // Pct is a value between -1.0 and +1.0, designating the current length\r\n        // of the swipe.\r\n        //\r\n        // If pct is negative, swipe towards the next() step, if positive,\r\n        // towards the prev() step.\r\n        //\r\n        // Note that pre-stepleave plugins such as goto can mess with what is a\r\n        // next() and prev() step, so we need to trigger the pre-stepleave event\r\n        // here, even if a swipe doesn't guarantee that the transition will\r\n        // actually happen.\r\n        //\r\n        // Calling swipe(), with any value of pct, won't in itself cause a\r\n        // transition to happen, this is just to animate the swipe. Once the\r\n        // transition is committed - such as at a touchend event - caller is\r\n        // responsible for also calling prev()/next() as appropriate.\r\n        //\r\n        // Note: For now, this function is made available to be used by the swipe plugin (which\r\n        // is the UI counterpart to this). It is a semi-internal API and intentionally not\r\n        // documented in DOCUMENTATION.md.\r\n        var swipe = function( pct ) {\r\n            if ( Math.abs( pct ) > 1 ) {\r\n                return;\r\n            }\r\n\r\n            // Prepare & execute the preStepLeave event\r\n            var event = { target: activeStep, detail: {} };\r\n            event.detail.swipe = pct;\r\n\r\n            // Will be ignored within swipe animation, but just in case a plugin wants to read this,\r\n            // humor them\r\n            event.detail.transitionDuration = config.transitionDuration;\r\n            var idx; // Needed by jshint\r\n            if ( pct < 0 ) {\r\n                idx = steps.indexOf( activeStep ) + 1;\r\n                event.detail.next = idx < steps.length ? steps[ idx ] : steps[ 0 ];\r\n                event.detail.reason = \"next\";\r\n            } else if ( pct > 0 ) {\r\n                idx = steps.indexOf( activeStep ) - 1;\r\n                event.detail.next = idx >= 0 ? steps[ idx ] : steps[ steps.length - 1 ];\r\n                event.detail.reason = \"prev\";\r\n            } else {\r\n\r\n                // No move\r\n                return;\r\n            }\r\n            if ( execPreStepLeavePlugins( event ) === false ) {\r\n\r\n                // If a preStepLeave plugin wants to abort the transition, don't animate a swipe\r\n                // For stop, this is probably ok. For substep, the plugin it self might want to do\r\n                // some animation, but that's not the current implementation.\r\n                return false;\r\n            }\r\n            var nextElement = event.detail.next;\r\n\r\n            var nextStep = stepsData[ \"impress-\" + nextElement.id ];\r\n\r\n            // If the same step is re-selected, force computing window scaling,\r\n            var nextScale = nextStep.scale * windowScale;\r\n            var k = Math.abs( pct );\r\n\r\n            var interpolatedStep = {\r\n                translate: {\r\n                    x: interpolate( currentState.translate.x, -nextStep.translate.x, k ),\r\n                    y: interpolate( currentState.translate.y, -nextStep.translate.y, k ),\r\n                    z: interpolate( currentState.translate.z, -nextStep.translate.z, k )\r\n                },\r\n                rotate: {\r\n                    x: interpolate( currentState.rotate.x, -nextStep.rotate.x, k ),\r\n                    y: interpolate( currentState.rotate.y, -nextStep.rotate.y, k ),\r\n                    z: interpolate( currentState.rotate.z, -nextStep.rotate.z, k ),\r\n\r\n                    // Unfortunately there's a discontinuity if rotation order changes. Nothing I\r\n                    // can do about it?\r\n                    order: k < 0.7 ? currentState.rotate.order : nextStep.rotate.order\r\n                },\r\n                scale: interpolate( currentState.scale * windowScale, nextScale, k )\r\n            };\r\n\r\n            css( root, {\r\n\r\n                // To keep the perspective look similar for different scales\r\n                // we need to 'scale' the perspective, too\r\n                perspective: config.perspective / interpolatedStep.scale + \"px\",\r\n                transform: scale( interpolatedStep.scale ),\r\n                transitionDuration: \"0ms\",\r\n                transitionDelay: \"0ms\"\r\n            } );\r\n\r\n            css( canvas, {\r\n                transform: rotate( interpolatedStep.rotate, true ) +\r\n                           translate( interpolatedStep.translate ),\r\n                transitionDuration: \"0ms\",\r\n                transitionDelay: \"0ms\"\r\n            } );\r\n        };\r\n\r\n        // Teardown impress\r\n        // Resets the DOM to the state it was before impress().init() was called.\r\n        // (If you called impress(rootId).init() for multiple different rootId's, then you must\r\n        // also call tear() once for each of them.)\r\n        var tear = function() {\r\n            lib.gc.teardown();\r\n            delete roots[ \"impress-root-\" + rootId ];\r\n        };\r\n\r\n        // Adding some useful classes to step elements.\r\n        //\r\n        // All the steps that have not been shown yet are given `future` class.\r\n        // When the step is entered the `future` class is removed and the `present`\r\n        // class is given. When the step is left `present` class is replaced with\r\n        // `past` class.\r\n        //\r\n        // So every step element is always in one of three possible states:\r\n        // `future`, `present` and `past`.\r\n        //\r\n        // There classes can be used in CSS to style different types of steps.\r\n        // For example the `present` class can be used to trigger some custom\r\n        // animations when step is shown.\r\n        lib.gc.addEventListener( root, \"impress:init\", function() {\r\n\r\n            // STEP CLASSES\r\n            steps.forEach( function( step ) {\r\n                step.classList.add( \"future\" );\r\n            } );\r\n\r\n            lib.gc.addEventListener( root, \"impress:stepenter\", function( event ) {\r\n                event.target.classList.remove( \"past\" );\r\n                event.target.classList.remove( \"future\" );\r\n                event.target.classList.add( \"present\" );\r\n            }, false );\r\n\r\n            lib.gc.addEventListener( root, \"impress:stepleave\", function( event ) {\r\n                event.target.classList.remove( \"present\" );\r\n                event.target.classList.add( \"past\" );\r\n            }, false );\r\n\r\n        }, false );\r\n\r\n        // Adding hash change support.\r\n        lib.gc.addEventListener( root, \"impress:init\", function() {\r\n\r\n            // Last hash detected\r\n            var lastHash = \"\";\r\n\r\n            // `#/step-id` is used instead of `#step-id` to prevent default browser\r\n            // scrolling to element in hash.\r\n            //\r\n            // And it has to be set after animation finishes, because in Chrome it\r\n            // makes transtion laggy.\r\n            // BUG: http://code.google.com/p/chromium/issues/detail?id=62820\r\n            lib.gc.addEventListener( root, \"impress:stepenter\", function( event ) {\r\n                window.location.hash = lastHash = \"#/\" + event.target.id;\r\n            }, false );\r\n\r\n            lib.gc.addEventListener( window, \"hashchange\", function() {\r\n\r\n                // When the step is entered hash in the location is updated\r\n                // (just few lines above from here), so the hash change is\r\n                // triggered and we would call `goto` again on the same element.\r\n                //\r\n                // To avoid this we store last entered hash and compare.\r\n                if ( window.location.hash !== lastHash ) {\r\n                    goto( lib.util.getElementFromHash() );\r\n                }\r\n            }, false );\r\n\r\n            // START\r\n            // by selecting step defined in url or first step of the presentation\r\n            goto( lib.util.getElementFromHash() || steps[ 0 ], 0 );\r\n        }, false );\r\n\r\n        body.classList.add( \"impress-disabled\" );\r\n\r\n        // Store and return API for given impress.js root element\r\n        return ( roots[ \"impress-root-\" + rootId ] = {\r\n            init: init,\r\n            goto: goto,\r\n            next: next,\r\n            prev: prev,\r\n            swipe: swipe,\r\n            tear: tear,\r\n            lib: lib\r\n        } );\r\n\r\n    };\r\n\r\n    // Flag that can be used in JS to check if browser have passed the support test\r\n    impress.supported = impressSupported;\r\n\r\n    // ADD and INIT LIBRARIES\r\n    // Library factories are defined in src/lib/*.js, and register themselves by calling\r\n    // impress.addLibraryFactory(libraryFactoryObject). They're stored here, and used to augment\r\n    // the API with library functions when client calls impress(rootId).\r\n    // See src/lib/README.md for clearer example.\r\n    // (Advanced usage: For different values of rootId, a different instance of the libaries are\r\n    // generated, in case they need to hold different state for different root elements.)\r\n    var libraryFactories = {};\r\n    impress.addLibraryFactory = function( obj ) {\r\n        for ( var libname in obj ) {\r\n            if ( obj.hasOwnProperty( libname ) ) {\r\n                libraryFactories[ libname ] = obj[ libname ];\r\n            }\r\n        }\r\n    };\r\n\r\n    // Call each library factory, and return the lib object that is added to the api.\r\n    var initLibraries = function( rootId ) { //jshint ignore:line\r\n        var lib = {};\r\n        for ( var libname in libraryFactories ) {\r\n            if ( libraryFactories.hasOwnProperty( libname ) ) {\r\n                if ( lib[ libname ] !== undefined ) {\r\n                    throw \"impress.js ERROR: Two libraries both tried to use libname: \" +  libname;\r\n                }\r\n                lib[ libname ] = libraryFactories[ libname ]( rootId );\r\n            }\r\n        }\r\n        return lib;\r\n    };\r\n\r\n    // `addPreInitPlugin` allows plugins to register a function that should\r\n    // be run (synchronously) at the beginning of init, before\r\n    // impress().init() itself executes.\r\n    impress.addPreInitPlugin = function( plugin, weight ) {\r\n        weight = parseInt( weight ) || 10;\r\n        if ( weight <= 0 ) {\r\n            throw \"addPreInitPlugin: weight must be a positive integer\";\r\n        }\r\n\r\n        if ( preInitPlugins[ weight ] === undefined ) {\r\n            preInitPlugins[ weight ] = [];\r\n        }\r\n        preInitPlugins[ weight ].push( plugin );\r\n    };\r\n\r\n    // Called at beginning of init, to execute all pre-init plugins.\r\n    var execPreInitPlugins = function( root ) { //jshint ignore:line\r\n        for ( var i = 0; i < preInitPlugins.length; i++ ) {\r\n            var thisLevel = preInitPlugins[ i ];\r\n            if ( thisLevel !== undefined ) {\r\n                for ( var j = 0; j < thisLevel.length; j++ ) {\r\n                    thisLevel[ j ]( root );\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // `addPreStepLeavePlugin` allows plugins to register a function that should\r\n    // be run (synchronously) at the beginning of goto()\r\n    impress.addPreStepLeavePlugin = function( plugin, weight ) { //jshint ignore:line\r\n        weight = parseInt( weight ) || 10;\r\n        if ( weight <= 0 ) {\r\n            throw \"addPreStepLeavePlugin: weight must be a positive integer\";\r\n        }\r\n\r\n        if ( preStepLeavePlugins[ weight ] === undefined ) {\r\n            preStepLeavePlugins[ weight ] = [];\r\n        }\r\n        preStepLeavePlugins[ weight ].push( plugin );\r\n    };\r\n\r\n    // Called at beginning of goto(), to execute all preStepLeave plugins.\r\n    var execPreStepLeavePlugins = function( event ) { //jshint ignore:line\r\n        for ( var i = 0; i < preStepLeavePlugins.length; i++ ) {\r\n            var thisLevel = preStepLeavePlugins[ i ];\r\n            if ( thisLevel !== undefined ) {\r\n                for ( var j = 0; j < thisLevel.length; j++ ) {\r\n                    if ( thisLevel[ j ]( event ) === false ) {\r\n\r\n                        // If a plugin returns false, the stepleave event (and related transition)\r\n                        // is aborted\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n} )( document, window );\r\n\r\n// THAT'S ALL FOLKS!\r\n//\r\n// Thanks for reading it all.\r\n// Or thanks for scrolling down and reading the last part.\r\n//\r\n// I've learnt a lot when building impress.js and I hope this code and comments\r\n// will help somebody learn at least some part of it.\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/impress.js?");

/***/ }),

/***/ "./src/libraries/impress/lib/gc.js":
/*!*****************************************!*\
  !*** ./src/libraries/impress/lib/gc.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Garbage collection utility\r\n *\r\n * This library allows plugins to add elements and event listeners they add to the DOM. The user\r\n * can call `impress().lib.gc.teardown()` to cause all of them to be removed from DOM, so that\r\n * the document is in the state it was before calling `impress().init()`.\r\n *\r\n * In addition to just adding elements and event listeners to the garbage collector, plugins\r\n * can also register callback functions to do arbitrary cleanup upon teardown.\r\n *\r\n * Henrik Ingo (c) 2016\r\n * MIT License\r\n */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var roots = [];\r\n    var rootsCount = 0;\r\n    var startingState = { roots: [] };\r\n\r\n    var libraryFactory = function( rootId ) {\r\n        if ( roots[ rootId ] ) {\r\n            return roots[ rootId ];\r\n        }\r\n\r\n        // Per root global variables (instance variables?)\r\n        var elementList = [];\r\n        var eventListenerList = [];\r\n        var callbackList = [];\r\n\r\n        recordStartingState( rootId );\r\n\r\n        // LIBRARY FUNCTIONS\r\n        // Definitions of the library functions we return as an object at the end\r\n\r\n        // `pushElement` adds a DOM element to the gc stack\r\n        var pushElement = function( element ) {\r\n            elementList.push( element );\r\n        };\r\n\r\n        // `appendChild` is a convenience wrapper that combines DOM appendChild with gc.pushElement\r\n        var appendChild = function( parent, element ) {\r\n            parent.appendChild( element );\r\n            pushElement( element );\r\n        };\r\n\r\n        // `pushEventListener` adds an event listener to the gc stack\r\n        var pushEventListener = function( target, type, listenerFunction ) {\r\n            eventListenerList.push( { target:target, type:type, listener:listenerFunction } );\r\n        };\r\n\r\n        // `addEventListener` combines DOM addEventListener with gc.pushEventListener\r\n        var addEventListener = function( target, type, listenerFunction ) {\r\n            target.addEventListener( type, listenerFunction );\r\n            pushEventListener( target, type, listenerFunction );\r\n        };\r\n\r\n        // `pushCallback` If the above utilities are not enough, plugins can add their own callback\r\n        // function to do arbitrary things.\r\n        var pushCallback = function( callback ) {\r\n            callbackList.push( callback );\r\n        };\r\n        pushCallback( function( rootId ) { resetStartingState( rootId ); } );\r\n\r\n        // `teardown` will\r\n        // - execute all callbacks in LIFO order\r\n        // - call `removeChild` on all DOM elements in LIFO order\r\n        // - call `removeEventListener` on all event listeners in LIFO order\r\n        // The goal of a teardown is to return to the same state that the DOM was before\r\n        // `impress().init()` was called.\r\n        var teardown = function() {\r\n\r\n            // Execute the callbacks in LIFO order\r\n            var i; // Needed by jshint\r\n            for ( i = callbackList.length - 1; i >= 0; i-- ) {\r\n                callbackList[ i ]( rootId );\r\n            }\r\n            callbackList = [];\r\n            for ( i = 0; i < elementList.length; i++ ) {\r\n                elementList[ i ].parentElement.removeChild( elementList[ i ] );\r\n            }\r\n            elementList = [];\r\n            for ( i = 0; i < eventListenerList.length; i++ ) {\r\n                var target   = eventListenerList[ i ].target;\r\n                var type     = eventListenerList[ i ].type;\r\n                var listener = eventListenerList[ i ].listener;\r\n                target.removeEventListener( type, listener );\r\n            }\r\n        };\r\n\r\n        var lib = {\r\n            pushElement: pushElement,\r\n            appendChild: appendChild,\r\n            pushEventListener: pushEventListener,\r\n            addEventListener: addEventListener,\r\n            pushCallback: pushCallback,\r\n            teardown: teardown\r\n        };\r\n        roots[ rootId ] = lib;\r\n        rootsCount++;\r\n        return lib;\r\n    };\r\n\r\n    // Let impress core know about the existence of this library\r\n    window.impress.addLibraryFactory( { gc: libraryFactory } );\r\n\r\n    // CORE INIT\r\n    // The library factory (gc(rootId)) is called at the beginning of impress(rootId).init()\r\n    // For the purposes of teardown(), we can use this as an opportunity to save the state\r\n    // of a few things in the DOM in their virgin state, before impress().init() did anything.\r\n    // Note: These could also be recorded by the code in impress.js core as these values\r\n    // are changed, but in an effort to not deviate too much from upstream, I'm adding\r\n    // them here rather than the core itself.\r\n    var recordStartingState = function( rootId ) {\r\n        startingState.roots[ rootId ] = {};\r\n        startingState.roots[ rootId ].steps = [];\r\n\r\n        // Record whether the steps have an id or not\r\n        var steps = document.getElementById( rootId ).querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            var el = steps[ i ];\r\n            startingState.roots[ rootId ].steps.push( {\r\n                el: el,\r\n                id: el.getAttribute( \"id\" )\r\n            } );\r\n        }\r\n\r\n        // In the rare case of multiple roots, the following is changed on first init() and\r\n        // reset at last tear().\r\n        if ( rootsCount === 0 ) {\r\n            startingState.body = {};\r\n\r\n            // It is customary for authors to set body.class=\"impress-not-supported\" as a starting\r\n            // value, which can then be removed by impress().init(). But it is not required.\r\n            // Remember whether it was there or not.\r\n            if ( document.body.classList.contains( \"impress-not-supported\" ) ) {\r\n                startingState.body.impressNotSupported = true;\r\n            } else {\r\n                startingState.body.impressNotSupported = false;\r\n            }\r\n\r\n            // If there's a <meta name=\"viewport\"> element, its contents will be overwritten by init\r\n            var metas = document.head.querySelectorAll( \"meta\" );\r\n            for ( i = 0; i < metas.length; i++ ) {\r\n                var m = metas[ i ];\r\n                if ( m.name === \"viewport\" ) {\r\n                    startingState.meta = m.content;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // CORE TEARDOWN\r\n    var resetStartingState = function( rootId ) {\r\n\r\n        // Reset body element\r\n        document.body.classList.remove( \"impress-enabled\" );\r\n        document.body.classList.remove( \"impress-disabled\" );\r\n\r\n        var root = document.getElementById( rootId );\r\n        var activeId = root.querySelector( \".active\" ).id;\r\n        document.body.classList.remove( \"impress-on-\" + activeId );\r\n\r\n        document.documentElement.style.height = \"\";\r\n        document.body.style.height = \"\";\r\n        document.body.style.overflow = \"\";\r\n\r\n        // Remove style values from the root and step elements\r\n        // Note: We remove the ones set by impress.js core. Otoh, we didn't preserve any original\r\n        // values. A more sophisticated implementation could keep track of original values and then\r\n        // reset those.\r\n        var steps = root.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            steps[ i ].classList.remove( \"future\" );\r\n            steps[ i ].classList.remove( \"past\" );\r\n            steps[ i ].classList.remove( \"present\" );\r\n            steps[ i ].classList.remove( \"active\" );\r\n            steps[ i ].style.position = \"\";\r\n            steps[ i ].style.transform = \"\";\r\n            steps[ i ].style[ \"transform-style\" ] = \"\";\r\n        }\r\n        root.style.position = \"\";\r\n        root.style[ \"transform-origin\" ] = \"\";\r\n        root.style.transition = \"\";\r\n        root.style[ \"transform-style\" ] = \"\";\r\n        root.style.top = \"\";\r\n        root.style.left = \"\";\r\n        root.style.transform = \"\";\r\n\r\n        // Reset id of steps (\"step-1\" id's are auto generated)\r\n        steps = startingState.roots[ rootId ].steps;\r\n        var step;\r\n        while ( step = steps.pop() ) {\r\n            if ( step.id === null ) {\r\n                step.el.removeAttribute( \"id\" );\r\n            } else {\r\n                step.el.setAttribute( \"id\", step.id );\r\n            }\r\n        }\r\n        delete startingState.roots[ rootId ];\r\n\r\n        // Move step div elements away from canvas, then delete canvas\r\n        // Note: There's an implicit assumption here that the canvas div is the only child element\r\n        // of the root div. If there would be something else, it's gonna be lost.\r\n        var canvas = root.firstChild;\r\n        var canvasHTML = canvas.innerHTML;\r\n        root.innerHTML = canvasHTML;\r\n\r\n        if ( roots[ rootId ] !== undefined ) {\r\n            delete roots[ rootId ];\r\n            rootsCount--;\r\n        }\r\n        if ( rootsCount === 0 ) {\r\n\r\n            // In the rare case that more than one impress root elements were initialized, these\r\n            // are only reset when all are uninitialized.\r\n            document.body.classList.remove( \"impress-supported\" );\r\n            if ( startingState.body.impressNotSupported ) {\r\n                document.body.classList.add( \"impress-not-supported\" );\r\n            }\r\n\r\n            // We need to remove or reset the meta element inserted by impress.js\r\n            var metas = document.head.querySelectorAll( \"meta\" );\r\n            for ( i = 0; i < metas.length; i++ ) {\r\n                var m = metas[ i ];\r\n                if ( m.name === \"viewport\" ) {\r\n                    if ( startingState.meta !== undefined ) {\r\n                        m.content = startingState.meta;\r\n                    } else {\r\n                        m.parentElement.removeChild( m );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n} )( document, window );\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/lib/gc.js?");

/***/ }),

/***/ "./src/libraries/impress/lib/util.js":
/*!*******************************************!*\
  !*** ./src/libraries/impress/lib/util.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Common utility functions\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Henrik Ingo (c) 2016\r\n * MIT License\r\n */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n    var roots = [];\r\n\r\n    var libraryFactory = function( rootId ) {\r\n        if ( roots[ rootId ] ) {\r\n            return roots[ rootId ];\r\n        }\r\n\r\n        // `$` returns first element for given CSS `selector` in the `context` of\r\n        // the given element or whole document.\r\n        var $ = function( selector, context ) {\r\n            context = context || document;\r\n            return context.querySelector( selector );\r\n        };\r\n\r\n        // `$$` return an array of elements for given CSS `selector` in the `context` of\r\n        // the given element or whole document.\r\n        var $$ = function( selector, context ) {\r\n            context = context || document;\r\n            return arrayify( context.querySelectorAll( selector ) );\r\n        };\r\n\r\n        // `arrayify` takes an array-like object and turns it into real Array\r\n        // to make all the Array.prototype goodness available.\r\n        var arrayify = function( a ) {\r\n            return [].slice.call( a );\r\n        };\r\n\r\n        // `byId` returns element with given `id` - you probably have guessed that ;)\r\n        var byId = function( id ) {\r\n            return document.getElementById( id );\r\n        };\r\n\r\n        // `getElementFromHash` returns an element located by id from hash part of\r\n        // window location.\r\n        var getElementFromHash = function() {\r\n\r\n            // Get id from url # by removing `#` or `#/` from the beginning,\r\n            // so both \"fallback\" `#slide-id` and \"enhanced\" `#/slide-id` will work\r\n            return byId( window.location.hash.replace( /^#\\/?/, \"\" ) );\r\n        };\r\n\r\n        // Throttling function calls, by Remy Sharp\r\n        // http://remysharp.com/2010/07/21/throttling-function-calls/\r\n        var throttle = function( fn, delay ) {\r\n            var timer = null;\r\n            return function() {\r\n                var context = this, args = arguments;\r\n                window.clearTimeout( timer );\r\n                timer = window.setTimeout( function() {\r\n                    fn.apply( context, args );\r\n                }, delay );\r\n            };\r\n        };\r\n\r\n        // `toNumber` takes a value given as `numeric` parameter and tries to turn\r\n        // it into a number. If it is not possible it returns 0 (or other value\r\n        // given as `fallback`).\r\n        var toNumber = function( numeric, fallback ) {\r\n            return isNaN( numeric ) ? ( fallback || 0 ) : Number( numeric );\r\n        };\r\n\r\n        // `triggerEvent` builds a custom DOM event with given `eventName` and `detail` data\r\n        // and triggers it on element given as `el`.\r\n        var triggerEvent = function( el, eventName, detail ) {\r\n            var event = document.createEvent( \"CustomEvent\" );\r\n            event.initCustomEvent( eventName, true, true, detail );\r\n            el.dispatchEvent( event );\r\n        };\r\n\r\n        var lib = {\r\n            $: $,\r\n            $$: $$,\r\n            arrayify: arrayify,\r\n            byId: byId,\r\n            getElementFromHash: getElementFromHash,\r\n            throttle: throttle,\r\n            toNumber: toNumber,\r\n            triggerEvent: triggerEvent\r\n        };\r\n        roots[ rootId ] = lib;\r\n        return lib;\r\n    };\r\n\r\n    // Let impress core know about the existence of this library\r\n    window.impress.addLibraryFactory( { util: libraryFactory } );\r\n\r\n} )( document, window );\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/lib/util.js?");

/***/ }),

/***/ "./src/libraries/impress/plugins/mobile/mobile.js":
/*!********************************************************!*\
  !*** ./src/libraries/impress/plugins/mobile/mobile.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Mobile devices support\r\n *\r\n * Allow presentation creators to hide all but 3 slides, to save resources, particularly on mobile\r\n * devices, using classes body.impress-mobile, .step.prev, .step.active and .step.next.\r\n *\r\n * Note: This plugin does not take into account possible redirections done with skip, goto etc\r\n * plugins. Basically it wouldn't work as intended in such cases, but the active step will at least\r\n * be correct.\r\n *\r\n * Adapted to a plugin from a submission by @Kzeni:\r\n * https://github.com/impress/impress.js/issues/333\r\n */\r\n/* global document, navigator */\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    var getNextStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = 0; i < steps.length; i++ ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i + 1 < steps.length ) {\r\n                    return steps[ i + 1 ];\r\n                } else {\r\n                    return steps[ 0 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n    var getPrevStep = function( el ) {\r\n        var steps = document.querySelectorAll( \".step\" );\r\n        for ( var i = steps.length - 1; i >= 0; i-- ) {\r\n            if ( steps[ i ] === el ) {\r\n                if ( i - 1 >= 0 ) {\r\n                    return steps[ i - 1 ];\r\n                } else {\r\n                    return steps[ steps.length - 1 ];\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    // Detect mobile browsers & add CSS class as appropriate.\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var body = document.body;\r\n        if ( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\r\n                 navigator.userAgent\r\n             ) ) {\r\n            body.classList.add( \"impress-mobile\" );\r\n        }\r\n\r\n        // Unset all this on teardown\r\n        var api = event.detail.api;\r\n        api.lib.gc.pushCallback( function() {\r\n            document.body.classList.remove( \"impress-mobile\" );\r\n            var prev = document.getElementsByClassName( \"prev\" )[ 0 ];\r\n            var next = document.getElementsByClassName( \"next\" )[ 0 ];\r\n            if ( typeof prev !== \"undefined\" ) {\r\n                prev.classList.remove( \"prev\" );\r\n            }\r\n            if ( typeof next !== \"undefined\" ) {\r\n                next.classList.remove( \"next\" );\r\n            }\r\n        } );\r\n    } );\r\n\r\n    // Add prev and next classes to the siblings of the newly entered active step element\r\n    // Remove prev and next classes from their current step elements\r\n    // Note: As an exception we break namespacing rules, as these are useful general purpose\r\n    // classes. (Naming rules would require us to use css classes mobile-next and mobile-prev,\r\n    // based on plugin name.)\r\n    document.addEventListener( \"impress:stepenter\", function( event ) {\r\n\t      var oldprev = document.getElementsByClassName( \"prev\" )[ 0 ];\r\n\t      var oldnext = document.getElementsByClassName( \"next\" )[ 0 ];\r\n\r\n\t      var prev = getPrevStep( event.target );\r\n\t      prev.classList.add( \"prev\" );\r\n\t      var next = getNextStep( event.target );\r\n\t      next.classList.add( \"next\" );\r\n\r\n\t      if ( typeof oldprev !== \"undefined\" ) {\r\n\t\t      oldprev.classList.remove( \"prev\" );\r\n              }\r\n\t      if ( typeof oldnext !== \"undefined\" ) {\r\n\t\t      oldnext.classList.remove( \"next\" );\r\n              }\r\n    } );\r\n} )( document );\r\n\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/plugins/mobile/mobile.js?");

/***/ }),

/***/ "./src/libraries/impress/plugins/navigation/navigation.js":
/*!****************************************************************!*\
  !*** ./src/libraries/impress/plugins/navigation/navigation.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Navigation events plugin\r\n *\r\n * As you can see this part is separate from the impress.js core code.\r\n * It's because these navigation actions only need what impress.js provides with\r\n * its simple API.\r\n *\r\n * This plugin is what we call an _init plugin_. It's a simple kind of\r\n * impress.js plugin. When loaded, it starts listening to the `impress:init`\r\n * event. That event listener initializes the plugin functionality - in this\r\n * case we listen to some keypress and mouse events. The only dependencies on\r\n * core impress.js functionality is the `impress:init` method, as well as using\r\n * the public api `next(), prev(),` etc when keys are pressed.\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Released under the MIT license.\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka\r\n *  version: 0.5.3\r\n *  url:     http://bartaz.github.com/impress.js/\r\n *  source:  http://github.com/bartaz/impress.js/\r\n *\r\n */\r\n/* global document */\r\n( function( document ) {\r\n    \"use strict\";\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n\r\n        // Getting API from event data.\r\n        // So you don't event need to know what is the id of the root element\r\n        // or anything. `impress:init` event data gives you everything you\r\n        // need to control the presentation that was just initialized.\r\n        var api = event.detail.api;\r\n        var gc = api.lib.gc;\r\n        var util = api.lib.util;\r\n\r\n        // Supported keys are:\r\n        // [space] - quite common in presentation software to move forward\r\n        // [up] [right] / [down] [left] - again common and natural addition,\r\n        // [pgdown] / [pgup] - often triggered by remote controllers,\r\n        // [tab] - this one is quite controversial, but the reason it ended up on\r\n        //   this list is quite an interesting story... Remember that strange part\r\n        //   in the impress.js code where window is scrolled to 0,0 on every presentation\r\n        //   step, because sometimes browser scrolls viewport because of the focused element?\r\n        //   Well, the [tab] key by default navigates around focusable elements, so clicking\r\n        //   it very often caused scrolling to focused element and breaking impress.js\r\n        //   positioning. I didn't want to just prevent this default action, so I used [tab]\r\n        //   as another way to moving to next step... And yes, I know that for the sake of\r\n        //   consistency I should add [shift+tab] as opposite action...\r\n        var isNavigationEvent = function( event ) {\r\n\r\n            // Don't trigger navigation for example when user returns to browser window with ALT+TAB\r\n            if ( event.altKey || event.ctrlKey || event.metaKey ) {\r\n                return false;\r\n            }\r\n\r\n            // In the case of TAB, we force step navigation always, overriding the browser\r\n            // navigation between input elements, buttons and links.\r\n            if ( event.keyCode === 9 ) {\r\n                return true;\r\n            }\r\n\r\n            // With the sole exception of TAB, we also ignore keys pressed if shift is down.\r\n            if ( event.shiftKey ) {\r\n                return false;\r\n            }\r\n\r\n            if ( ( event.keyCode >= 32 && event.keyCode <= 34 ) ||\r\n                 ( event.keyCode >= 37 && event.keyCode <= 40 ) ) {\r\n                return true;\r\n            }\r\n        };\r\n\r\n        // KEYBOARD NAVIGATION HANDLERS\r\n\r\n        // Prevent default keydown action when one of supported key is pressed.\r\n        gc.addEventListener( document, \"keydown\", function( event ) {\r\n            if ( isNavigationEvent( event ) ) {\r\n                event.preventDefault();\r\n            }\r\n        }, false );\r\n\r\n        // Trigger impress action (next or prev) on keyup.\r\n        gc.addEventListener( document, \"keyup\", function( event ) {\r\n            if ( isNavigationEvent( event ) ) {\r\n                if ( event.shiftKey ) {\r\n                    switch ( event.keyCode ) {\r\n                        case 9: // Shift+tab\r\n                            api.prev();\r\n                            break;\r\n                    }\r\n                } else {\r\n                    switch ( event.keyCode ) {\r\n                        case 33: // Pg up\r\n                        case 37: // Left\r\n                        case 38: // Up\r\n                                 api.prev( event );\r\n                                 break;\r\n                        case 9:  // Tab\r\n                        case 32: // Space\r\n                        case 34: // Pg down\r\n                        case 39: // Right\r\n                        case 40: // Down\r\n                                 api.next( event );\r\n                                 break;\r\n                    }\r\n                }\r\n                event.preventDefault();\r\n            }\r\n        }, false );\r\n\r\n        // Delegated handler for clicking on the links to presentation steps\r\n        gc.addEventListener( document, \"click\", function( event ) {\r\n\r\n            // Event delegation with \"bubbling\"\r\n            // check if event target (or any of its parents is a link)\r\n            var target = event.target;\r\n            try {\r\n                while ( ( target.tagName !== \"A\" ) &&\r\n                        ( target !== document.documentElement ) ) {\r\n                    target = target.parentNode;\r\n                }\r\n\r\n                if ( target.tagName === \"A\" ) {\r\n                    var href = target.getAttribute( \"href\" );\r\n\r\n                    // If it's a link to presentation step, target this step\r\n                    if ( href && href[ 0 ] === \"#\" ) {\r\n                        target = document.getElementById( href.slice( 1 ) );\r\n                    }\r\n                }\r\n\r\n                if ( api.goto( target ) ) {\r\n                    event.stopImmediatePropagation();\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n            catch ( err ) {\r\n\r\n                // For example, when clicking on the button to launch speaker console, the button\r\n                // is immediately deleted from the DOM. In this case target is a DOM element when\r\n                // we get it, but turns out to be null if you try to actually do anything with it.\r\n                if ( err instanceof TypeError &&\r\n                     err.message === \"target is null\" ) {\r\n                    return;\r\n                }\r\n                throw err;\r\n            }\r\n        }, false );\r\n\r\n        // Delegated handler for clicking on step elements\r\n        gc.addEventListener( document, \"click\", function( event ) {\r\n            var target = event.target;\r\n            try {\r\n\r\n                // Find closest step element that is not active\r\n                while ( !( target.classList.contains( \"step\" ) &&\r\n                        !target.classList.contains( \"active\" ) ) &&\r\n                        ( target !== document.documentElement ) ) {\r\n                    target = target.parentNode;\r\n                }\r\n\r\n                if ( api.goto( target ) ) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n            catch ( err ) {\r\n\r\n                // For example, when clicking on the button to launch speaker console, the button\r\n                // is immediately deleted from the DOM. In this case target is a DOM element when\r\n                // we get it, but turns out to be null if you try to actually do anything with it.\r\n                if ( err instanceof TypeError &&\r\n                     err.message === \"target is null\" ) {\r\n                    return;\r\n                }\r\n                throw err;\r\n            }\r\n        }, false );\r\n\r\n        // Add a line to the help popup\r\n        util.triggerEvent( document, \"impress:help:add\", { command: \"Left &amp; Right\",\r\n                                                           text: \"Previous &amp; Next step\",\r\n                                                           row: 1 } );\r\n\r\n    }, false );\r\n\r\n} )( document );\r\n\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/plugins/navigation/navigation.js?");

/***/ }),

/***/ "./src/libraries/impress/plugins/resize/resize.js":
/*!********************************************************!*\
  !*** ./src/libraries/impress/plugins/resize/resize.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Resize plugin\r\n *\r\n * Rescale the presentation after a window resize.\r\n *\r\n * Copyright 2011-2012 Bartek Szopka (@bartaz)\r\n * Released under the MIT license.\r\n * ------------------------------------------------\r\n *  author:  Bartek Szopka\r\n *  version: 0.5.3\r\n *  url:     http://bartaz.github.com/impress.js/\r\n *  source:  http://github.com/bartaz/impress.js/\r\n *\r\n */\r\n\r\n/* global document, window */\r\n\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    // Wait for impress.js to be initialized\r\n    document.addEventListener( \"impress:init\", function( event ) {\r\n        var api = event.detail.api;\r\n\r\n        // Rescale presentation when window is resized\r\n        api.lib.gc.addEventListener( window, \"resize\", api.lib.util.throttle( function() {\r\n\r\n            // Force going to active step again, to trigger rescaling\r\n            api.goto( document.querySelector( \".step.active\" ), 500 );\r\n        }, 250 ), false );\r\n    }, false );\r\n\r\n} )( document, window );\r\n\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/plugins/resize/resize.js?");

/***/ }),

/***/ "./src/libraries/impress/plugins/touch/touch.js":
/*!******************************************************!*\
  !*** ./src/libraries/impress/plugins/touch/touch.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Support for swipe and tap on touch devices\r\n *\r\n * This plugin implements navigation for plugin devices, via swiping left/right,\r\n * or tapping on the left/right edges of the screen.\r\n *\r\n *\r\n *\r\n * Copyright 2015: Andrew Dunai (@and3rson)\r\n * Modified to a plugin, 2016: Henrik Ingo (@henrikingo)\r\n *\r\n * MIT License\r\n */\r\n/* global document, window */\r\n( function( document, window ) {\r\n    \"use strict\";\r\n\r\n    // Touch handler to detect swiping left and right based on window size.\r\n    // If the difference in X change is bigger than 1/20 of the screen width,\r\n    // we simply call an appropriate API function to complete the transition.\r\n    var startX = 0;\r\n    var lastX = 0;\r\n    var lastDX = 0;\r\n    var threshold = window.innerWidth / 20;\r\n\r\n    document.addEventListener( \"touchstart\", function( event ) {\r\n        lastX = startX = event.touches[ 0 ].clientX;\r\n    } );\r\n\r\n    document.addEventListener( \"touchmove\", function( event ) {\r\n         var x = event.touches[ 0 ].clientX;\r\n         var diff = x - startX;\r\n\r\n         // To be used in touchend\r\n         lastDX = lastX - x;\r\n         lastX = x;\r\n\r\n         window.impress().swipe( diff / window.innerWidth );\r\n     } );\r\n\r\n     document.addEventListener( \"touchend\", function() {\r\n         var totalDiff = lastX - startX;\r\n         if ( Math.abs( totalDiff ) > window.innerWidth / 5 && ( totalDiff * lastDX ) <= 0 ) {\r\n             if ( totalDiff > window.innerWidth / 5 && lastDX <= 0 ) {\r\n                 window.impress().prev();\r\n             } else if ( totalDiff < -window.innerWidth / 5 && lastDX >= 0 ) {\r\n                 window.impress().next();\r\n             }\r\n         } else if ( Math.abs( lastDX ) > threshold ) {\r\n             if ( lastDX < -threshold ) {\r\n                 window.impress().prev();\r\n             } else if ( lastDX > threshold ) {\r\n                 window.impress().next();\r\n             }\r\n         } else {\r\n\r\n             // No movement - move (back) to the current slide\r\n             window.impress().goto( document.querySelector( \"#impress .step.active\" ) );\r\n         }\r\n     } );\r\n\r\n     document.addEventListener( \"touchcancel\", function() {\r\n\r\n             // Move (back) to the current slide\r\n             window.impress().goto( document.querySelector( \"#impress .step.active\" ) );\r\n     } );\r\n\r\n} )( document, window );\r\n\n\n//# sourceURL=webpack:///./src/libraries/impress/plugins/touch/touch.js?");

/***/ }),

/***/ "./src/scripts/hint.js":
/*!*****************************!*\
  !*** ./src/scripts/hint.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const hint = document.querySelector(\".hint\");\r\n\r\nif (\"ontouchstart\" in document.documentElement) {\r\n  hint.innerHTML = \"Swipe left to start\";\r\n} else {\r\n  hint.innerHTML =\"Use a spacebar or arrow keys to navigate\";\r\n}\r\n\n\n//# sourceURL=webpack:///./src/scripts/hint.js?");

/***/ }),

/***/ "./src/scripts/index.js":
/*!******************************!*\
  !*** ./src/scripts/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.html */ \"./src/index.html\");\n/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/index.scss */ \"./src/styles/index.scss\");\n/* harmony import */ var _styles_index_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_index_scss__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _icons_at_solid_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../icons/at-solid.svg */ \"./src/icons/at-solid.svg\");\n/* harmony import */ var _icons_github_brands_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../icons/github-brands.svg */ \"./src/icons/github-brands.svg\");\n/* harmony import */ var _icons_linkedin_brands_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../icons/linkedin-brands.svg */ \"./src/icons/linkedin-brands.svg\");\n/* harmony import */ var _libraries_impress_impress__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../libraries/impress/impress */ \"./src/libraries/impress/impress.js\");\n/* harmony import */ var _libraries_impress_impress__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_impress__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _libraries_impress_lib_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../libraries/impress/lib/util */ \"./src/libraries/impress/lib/util.js\");\n/* harmony import */ var _libraries_impress_lib_util__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_lib_util__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _libraries_impress_lib_gc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../libraries/impress/lib/gc */ \"./src/libraries/impress/lib/gc.js\");\n/* harmony import */ var _libraries_impress_lib_gc__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_lib_gc__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _libraries_impress_plugins_navigation_navigation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../libraries/impress/plugins/navigation/navigation */ \"./src/libraries/impress/plugins/navigation/navigation.js\");\n/* harmony import */ var _libraries_impress_plugins_navigation_navigation__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_plugins_navigation_navigation__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _libraries_impress_plugins_mobile_mobile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../libraries/impress/plugins/mobile/mobile */ \"./src/libraries/impress/plugins/mobile/mobile.js\");\n/* harmony import */ var _libraries_impress_plugins_mobile_mobile__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_plugins_mobile_mobile__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _libraries_impress_plugins_resize_resize__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../libraries/impress/plugins/resize/resize */ \"./src/libraries/impress/plugins/resize/resize.js\");\n/* harmony import */ var _libraries_impress_plugins_resize_resize__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_plugins_resize_resize__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _libraries_impress_plugins_touch_touch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../libraries/impress/plugins/touch/touch */ \"./src/libraries/impress/plugins/touch/touch.js\");\n/* harmony import */ var _libraries_impress_plugins_touch_touch__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_libraries_impress_plugins_touch_touch__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _hint__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./hint */ \"./src/scripts/hint.js\");\n/* harmony import */ var _hint__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_hint__WEBPACK_IMPORTED_MODULE_12__);\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n* impress.js\r\n* */\r\n\r\n\r\n/*\r\n* Utilities for impress.js\r\n* */\r\n\r\n\r\n\r\n/*\r\n* Plugins for impress.js\r\n* */\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n* Scripts\r\n* */\r\n\r\n\r\nconst impress_DOM_element = document.getElementById(\"impress\");\r\n\r\n/*\r\n* Setting up width and height for impress.js\r\n* */\r\n\r\nif (window.innerWidth > 768) {\r\n  const coefficient = 1.5;\r\n  impress_DOM_element.dataset.height = window.innerHeight * coefficient;\r\n  impress_DOM_element.dataset.width = window.innerWidth * coefficient;\r\n}\r\n\r\n// impress_DOM_element.dataset.height = impress_DOM_element.dataset.width =\r\n//   window.innerHeight > window.innerWidth\r\n//     ? window.innerHeight\r\n//     : window.innerWidth;\r\n\r\nimpress().init();\r\n\r\n// if (\"ontouchstart\" in document.documentElement) {\r\n//\r\n// }\r\n// console.log(impress_DOM_element);\r\n// debugger\r\n\n\n//# sourceURL=webpack:///./src/scripts/index.js?");

/***/ }),

/***/ "./src/styles/index.scss":
/*!*******************************!*\
  !*** ./src/styles/index.scss ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./src/styles/index.scss?");

/***/ }),

/***/ 0:
/*!************************************!*\
  !*** multi ./src/scripts/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/scripts/index.js */\"./src/scripts/index.js\");\n\n\n//# sourceURL=webpack:///multi_./src/scripts/index.js?");

/***/ })

/******/ });